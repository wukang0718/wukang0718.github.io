{"meta":{"title":"前端武康","subtitle":"","description":"前端博客 Vue React Node","author":"武康","url":"https://wukang0718.com","root":"/"},"pages":[{"title":"关于","date":"2021-08-30T05:54:04.000Z","updated":"2021-08-30T05:54:20.896Z","comments":true,"path":"about/index.html","permalink":"https://wukang0718.com/about/","excerpt":"","text":""},{"title":"标签","date":"2021-08-30T05:51:09.000Z","updated":"2021-08-30T05:56:35.571Z","comments":true,"path":"tags/index.html","permalink":"https://wukang0718.com/tags/","excerpt":"","text":""},{"title":"分类","date":"2021-08-30T05:48:12.000Z","updated":"2021-08-30T05:53:39.290Z","comments":true,"path":"categories/index.html","permalink":"https://wukang0718.com/categories/","excerpt":"","text":""}],"posts":[{"title":"vue-router中query参数做自动加密、解密","slug":"vue-router中query参数做自动加密、解密","date":"2021-09-04T10:46:27.000Z","updated":"2021-09-04T10:48:50.902Z","comments":true,"path":"2021/09/04/vue-router中query参数做自动加密、解密/","link":"","permalink":"https://wukang0718.com/2021/09/04/vue-router%E4%B8%ADquery%E5%8F%82%E6%95%B0%E5%81%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/","excerpt":"","text":"vue-router 插件，对vue-router使用中query参数做自动加密、解密仓库地址​ github: https://github.com/wukang0718/vueRouterEncryption ​ gitee: https://gitee.com/wu_kang0718/vueRouterEncryption 使用方式 加密需要依赖 crypto-js 库，安装： npm 1npm install crypto-js --save yarn 1yarn add crypto-js 将utils文件夹放入项目 （最好是放在router目录下 ） 中，在router的初始化文件中，引入utils/query.js的stringifyQuery和parseQuery方法，在new VueRouter是时候传递参数， 修改utils/encryption.js中的baseCryptoCode设置每个项目唯一的值 例：（参考index.js） 1234567891011121314151617import Vue from &quot;vue&quot;import VueRouter from &quot;vue-router&quot;;import &#123; stringifyQuery, parseQuery &#125; from &quot;./utils/query&quot;;Vue.use(VueRouter);const routes = [];const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, stringifyQuery: stringifyQuery, // 序列化query参数 parseQuery: parseQuery, // 反序列化query参数 routes&#125;);export default router 结构 utils/encryption.js 文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js） getEncrypt 加密 对应的解密方法（getDecrypt） getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64） getDecrypt 解密 对应的加密方法（getEncrypt） getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64） utils/query.js 文件提供了序列化和反序列化的方法 stringifyQuery 序列化对象并 加密 parseQuery 解密 反序列化对象 原理 在创建路由的时候，添加两个方法 stringifyQuery: 序列化传入的query参数，方法可以接收一个对象参数 在new Router的时候传递这个属性，在序列化query参数的就执行这个方法，不会执行默认的方法，序列化后在地址栏显示序列化之后的参数 parseQuery: 解析地址栏参数，方法接收一个字符串参数 在new Router的时候传递这个属性，在解析query参数的时候，回执行这个方法，不会在执行默认的方法， 注： 这个方法只解析path中的参数，或者浏览器刷新的时候的地址栏的参数，不会对在query参数对处理，如： 123456this.$router.push(&#123; path: &quot;foo?a=123&quot;, query: &#123; b: 345 &#125;&#125;) 在执行这段代码的时候，parseQuery方法不会对query:&#123;b: 345&#125;进行解析,会解析path:&quot;foo?a=123&quot;中的a=123的字符串 序列化 vue-router在执行createRoute的时候，获取fullPath会执行getFullPath方法 createRouter 方法 会获取在 new VueRouter的时候传递的stringifyQuery方法，如果没有这个方法，就会在getFullPath的时候，使用默认的方法 源码位置：“/vue-router/src/utils/route.js” 12345678910111213141516171819202122232425262728export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || &#x27;/&#x27;, hash: location.hash || &#x27;&#x27;, query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125; getFullPath 方法接收两个参数（路由对象， 序列化query的方法） 源码： 1234567function getFullPath ( &#123; path, query = &#123;&#125;, hash = &#x27;&#x27; &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || &#x27;/&#x27;) + stringify(query) + hash&#125; 反序列化 在调用push的时候，会执行this.router.match方法，match方法会执行normalizeLocation normalizeLocation通过resolveQuery方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法） 反序列化方法会通过router &amp;&amp; router.options.parseQuery获取，如果在new VueRouter的时候传递了parseQuery方法，就是用该方法，如果没有就在resolveQuery方法中使用默认的方法 源码地址：“/vue-router/src/utils/location.js” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === &#x27;string&#x27; ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; return next &#125; else if (next.name) &#123; next = extend(&#123;&#125;, raw) const params = next.params if (params &amp;&amp; typeof params === &#x27;object&#x27;) &#123; next.params = extend(&#123;&#125;, params) &#125; return next &#125; // relative params if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; const parsedPath = parsePath(next.path || &#x27;&#x27;) const basePath = (current &amp;&amp; current.path) || &#x27;/&#x27; const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== &#x27;#&#x27;) &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125;","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"}]},{"title":"为什么微任务比宏任务执行快","slug":"为什么微任务比宏任务执行快","date":"2021-09-04T07:49:41.000Z","updated":"2021-09-04T07:55:37.599Z","comments":true,"path":"2021/09/04/为什么微任务比宏任务执行快/","link":"","permalink":"https://wukang0718.com/2021/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BF%AB/","excerpt":"","text":"为什么微任务比宏任务执行快 微任务叫 microtask 称为 jobs，是由JavaScript自身发起的 宏任务叫 macrotask 称为 task，是由宿主环境发起的 Event Loop中，每一次循环称为tick 主要区别 宏任务（macrotask） 微任务（microtask） 谁发起的 Nodejs/浏览器 JavaScript自身 具体事件 script 标签setTimeout/setIntervalUiRenderingpostMessage/messageChannelsetImmediate/IO PromiseMutationObserverprocess.nextTick 谁先执行 后执行 先执行 会触发新一轮的tick吗 会 不会","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}],"categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"},{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}