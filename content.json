{"meta":{"title":"前端武康","subtitle":"","description":"前端博客 Vue React Node","author":"武康","url":"https://wukang0718.com","root":"/"},"pages":[{"title":"分类","date":"2021-08-30T05:48:12.000Z","updated":"2021-08-30T05:53:39.290Z","comments":true,"path":"categories/index.html","permalink":"https://wukang0718.com/categories/","excerpt":"","text":""},{"title":"标签","date":"2021-08-30T05:51:09.000Z","updated":"2021-08-30T05:56:35.571Z","comments":true,"path":"tags/index.html","permalink":"https://wukang0718.com/tags/","excerpt":"","text":""},{"title":"关于","date":"2021-08-30T05:54:04.000Z","updated":"2021-08-30T05:54:20.896Z","comments":true,"path":"about/index.html","permalink":"https://wukang0718.com/about/","excerpt":"","text":""}],"posts":[{"title":"第三篇-vue3 项目中配置模式和环境变量","slug":"第三篇-vue3-项目中配置模式和环境变量","date":"2021-09-08T03:15:47.000Z","updated":"2021-09-08T03:18:07.960Z","comments":true,"path":"2021/09/08/第三篇-vue3-项目中配置模式和环境变量/","link":"","permalink":"https://wukang0718.com/2021/09/08/%E7%AC%AC%E4%B8%89%E7%AF%87-vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"Vue内置的模式Vue CLI 内置了三种模式 developement 模式，使用 vue-cli-service serve 命令的时候，启动的开发环境就是这个模式，这个模式下运行的 webpack 会启动热更新，不会对资源进行 hash 也不会打出 vendor bundles，目的是为了在开发的时候能够快速重新构建。 test 模式，使用 vue-cli-service test:unit 命令的时候，启动的单元测试的环境就是这个模式，这个模式下的 webpack 不会处理图片以及一些对单元测试非必需的其他资源。 production 模式，vue-cli-service build 命令的时候，运用的就是这个模式，这个模式的 webpack 会运行 mode=production 的配置 自定义运行模式在执行 vue-cli-service 的命令的时候，可以通过 --mode 指定想要运行的模式，这将会覆盖默认的模式 例如在公司开发中，都会有一个测试环境，那么这个测试环境会有一些和开发/生产环境都不一样的东西，比如说我们后端服务的url，那么我们就可以给这个测试环境的打包指定一个模式，这样在打包的时候，会从指定模式的环境文件中加载环境变量，在 package.json 中添加一个 script 命令 &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;， 注意：尽量不要和默认的模式冲突 package.json 123456789101112&#123; ... &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;, &quot;test:e2e&quot;: &quot;vue-cli-service test:e2e&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125; ...&#125; 执行 npm run build:t 的时候会运行 t 模式，会从 .env / .env.local / .env.t / .env.t.local 这些文件中加载环境变量，稍后来创建环境文件 Vue内置的环境变量Vue CLI 内置了两个环境变量 环境变量/模式 development test production NODE_ENV development test production BASE_URL（就是vue.config.js中的publicPath ，默认是 /） / / / 自定义环境变量 当运行 vue-cli-service 命令时，所有的环境变量都从对应的环境文件中载入，这就给我们提供了自定义环境变量的方式 什么是环境文件在项目根目录下可以创建四种形式的环境文件 1234.env # 在所有的环境中被载入.env.local # 在所有的环境中被载入，但会被 git 忽略.env.[mode] # 只在指定的模式中被载入.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 环境文件只包含环境变量的“键=值”对： 1VUE_APP_BASE_URL=&quot;http://dev.server.com&quot; // 后端服务的url 环境文件的优先级 Vue CLI 启动时已经存在的环境变量拥有最高优先级，不会被 .env 文件覆盖，但是可以被 .env.[mode] 文件覆盖 为一个特定模式准备的环境文件 (例如 .env.t) 将会比一般的环境文件 (例如 .env) 拥有更高的优先级。 环境文件是通过运行 vue-cli-service 命令载入的，因此环境文件发生变化，你需要重启服务。 动态计算环境变量在 vue.config.js 文件中计算环境变量。它们仍然需要以 VUE_APP_ 前缀开头。 例如计算每次编译的版本和时间 1234/* eslint-disable @typescript-eslint/no-var-requires */const pkg = require(&quot;./package.json&quot;);process.env.VUE_APP_VERSION = pkg.version;process.env.VUE_APP_DATE_TIME = new Date().toLocaleString(); 环境变量的运用只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到代码中 例如上面提到的 VUE_APP_BASE_URL 就是已 VUE_APP 开头的 建议不要在任何文件修改 BASE_URL 的值，在执行 vue-cli-service build 命令的模式环境文件里都建议把 NODE_ENV 改成 production 先来配置一下环境变量看一下环境变量的用法 在根目录新建以下文件 .env.development 指定开发环境使用的环境变量 .env.production 指定生产环境使用的环境变量 .env.t 指定测试环境使用的环境变量 就简单配置一个用来区分运行环境的环境变量 VUE_APP_ENV ，这个变量可以任意取，只要求已 VUE_APP 开头，并且应该在所有的环境文件都包含这个环境变量 .env.development 1VUE_APP_ENV=dev .env.production 1VUE_APP_ENV=prod .env.t 1VUE_APP_ENV=t 在项目中使用环境变量通过 process.env.[环境变量] 的方式获取到运行模式的环境文件配置的环境变量的值 在 src/App.vue 中使用一下 123456789101112&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 忽略其他代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&#123;&#123; env &#125;&#125;&lt;/div&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; Ref, ref &#125; from &quot;@vue/reactivity&quot;;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;const env: Ref = ref(process.env.VUE_APP_ENV); // 启动项目这个值是dev&lt;/script&gt; 运行其他模式看一下结果，命令行执行 123yarn serve --mode t#ornpm run serve --mode t 运行 production 模式 123yarn serve --mode production#ornpm run serve --mode production 环境变量不只是在 src 下的文件可以使用，在根目录下的 babel.config.js / vue.config.js 等文件中也可以使用. 在 public/index.html 中使用环境变量所有解析出来的环境变量都可以在 public/index.html 中以 **HTML 插值**中介绍的方式使用。 因为 index 文件被用作模板，所以你可以使用 lodash template 语法插入内容： &lt;%= VALUE %&gt; 用来做不转义插值； &lt;%- VALUE %&gt; 用来做 HTML 转义插值； &lt;% expression %&gt; 用来描述 JavaScript 流程控制。 例如在 index.html 使用一个 meta 标签标记我们项目的模式、版本和打包的时间 123&lt;meta content=&quot;&lt;%= VUE_APP_ENV %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_VERSION %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_DATE_TIME %&gt;&quot;&gt; 执行打包命令看 dist 目录输出的html 123yarn build --mode development#or npm run build --mode development 运行 t 模式的打包 123yarn build:t#or npm run build:t 运行 production 模式的打包，build 的默认模式就是 production 123yarn build#or npm run build 实际开发中还需要的运行环境经过刚才的打包发现，在指定 --mode t 的时候，打包后的文件没有被压缩 这是因为没有指定 t 模式的 NODE_ENV=production ，所以使用的是 development 的 webpack 配置 所以要在环境文件中指定 NODE_ENV 的值 .env.development 1NODE_ENV=development .env.t 1NODE_ENV=production .env.production 1NODE_ENV=production 再次执行 yarn build:t 或 npm run build:t，dist 目录下的文件就已经是压缩过的了 还有其他实际开发中需要配置的环境变量，比如后端接口的地址，具体看自己项目吧 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第二篇-Vue3 项目中集成 element-plus","slug":"第二篇-Vue3-项目中集成-element-plus","date":"2021-09-07T11:06:07.000Z","updated":"2021-09-08T03:19:10.620Z","comments":true,"path":"2021/09/07/第二篇-Vue3-项目中集成-element-plus/","link":"","permalink":"https://wukang0718.com/2021/09/07/%E7%AC%AC%E4%BA%8C%E7%AF%87-Vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90-element-plus/","excerpt":"","text":"基于上次使用 cli 搭建的 vue3 的项目来添加 element-plus cli搭建vue3项目 安装element-plus在项目所在目录打开命令行工具，执行以下命令安装 123npm install element-plus --save#or yarn add element-plus 我这里安装的最新版本是 1.1.0-beta.9 升级sass、sass-loader为什么要升级 sass、 sass-loader? 使用脚手架安装的 sass 的版本是 1.26.5 ， sass-loader 的版本是 8.0.2，而 element-plus@1.1.0-beta.9 版本的源码中使用的 sass 的版本是 1.39.0, sass-loader 的版本是 10.1.1 那我们就需要安装一下这两个版本，命令行执行以下命令 123npm install sass@1.39.0 sass-loader@10.1.1 --save-dev#or yarn add sass@1.39.0 sass-loader@10.1.1 --dev 使用按需引入为什么要使用按需引入? element-plus 的组件比较多，而我们的项目开发中并不一定会用到所有的组件，如果我们直接引入所有的组件，那么项目打包之后的文件体积较大，会导致浏览器的加载时间长，从而导致一些白屏时间长等的问题。 使用按需引入之后，在项目打包的时候，只会把我们引入的组件进行打包，其他我们没有引入使用的组件，不会打包我们的项目中，减少我们项目的体积，加快浏览器的加载效率。 配置按需引入 首先需要下载一个 babel 的插件 babel-plugin-import，命令行执行 123npm install babel-plugin-import --save-dev#oryarn add babel-plugin-import --dev 找到项目根目录下的 babel.config.js 文件 添加 babel.config.js 配置，将文件内容修改为 1234567891011121314151617module.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;element-plus&quot;, // 引入组件 customName: (name) =&gt; &#123; name = name.slice(3); return `element-plus/lib/components/$&#123;name&#125;`; &#125;, // 不引入样式，因为之后会做主题定制，所以需要引入所有样式的scss文件 &#125;, ], ],&#125;; 测试按需引入是否正确在 src/main.ts 中，引入 element-plus 的样式文件 1import &quot;element-plus/dist/index.css&quot;; 在 src/App.vue 中，添加 script 代码 123&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt; 在 template 中添加一个 el-button 组件 1&lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; App.vue 123456789101112131415&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ... 省略css代码&lt;/style&gt; 运行项目，浏览器访问 el-button 组件就很好的显示在了页面上 把按需引入提取到单独的目录为什么要提取到单独的目录来，有一个好处就是只需要在这里引入一次，并注册成全局的组件之后，就不需要在每个需要用到 element-plus 的组件里面再次引入了。 我一般会在 src 目录下，创建一个 theme 文件夹，专门做按需加载和主题定制 创建一个 theme 文件夹，并在目录下创建一个 index.ts 的文件 将刚才引入 el-button 的代码放到这个文件中，并将组件注册为全局的组件，在这里文件里，我们将导出一个函数，这个函数会作为 Vue 的一个插件，在 main.ts 中通过 app.use() 的方式注册到全局 index.ts 123456import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.use(ElButton);&#125;; main.ts 123456789101112import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;import Element from &quot;./theme&quot;;const app = createApp(App);app.use(store);app.use(router);app.use(Element);app.mount(&quot;#app&quot;); 测试一下我们的提取的按需引入是否正确 删掉刚才在 App.vue 中添加的 script 标签 1234567891011&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 刷新浏览器，发现 el-button 的组件渲染的和之前一样，没有问题 配置 element-plus 的全局属性element-plus 还为我们提供了两个可以全局配置的属性， size 和 zIndex，还是在我们的 theme/index.ts 文件中配置，修改导出的函数，给 app.config.globalProperties.$ELEMENT 属性赋值 1234export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton);&#125;; 然后打开浏览器，可以发现 el-button 的按钮，比刚才小了很多了 配置 i18nElementPlus 组件内部默认使用英语，如果我们希望我们的项目中默认使用中文，就需要对 element-plus 配置 i18n，先来看一个默认英文的例子 在 theme/index.ts 文件中引入 ElCalendar 组件 12345678import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar);&#125;; 在 src/App.vue 中使用 ElCalendar 组件 123456789&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt;&lt;/template&gt; 打开浏览器会发现日历的头部和按钮都是显示的英文 接下来我们配置 i18n，还是在我们的 theme/index.ts 文件中，引入 ElConfigProvider 组件，并在 src/App.vue 中使用 theme/index.ts 123456789import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ...&lt;/style&gt; 再次打开浏览器，就可以看到日历的按钮已经变成中文了，但是日历的头部还是英文的展示，这是因为 element-plus 的中的时间和日期相关的组件，都使用了 dayjs 格式化，所以我们这里想把日历的头部 改成中文还需要引入一下 dayjs 的中文包 在 theme/index.ts 中添加引入 1import &quot;dayjs/locale/zh-cn&quot;; 配置主题定制element-plus 给我们提供了一套默认的主题，同时给我们提供了四种方法，可以进行不同程度的样式自定义。这里只说其中的一种，其他的方式，感兴趣的可以前往官网查阅 通过修改scss变量的方式，替换主题的样式在我们的 src/theme 目录下新建一个 element-variables.scss 的文件，之后我们需要定制的 element-plus 主题的 scss 变量都会在这个文件重写。 不要使用官网推荐的 element-theme 工具，已经很久没有人维护了，在最新版本的node环境下使用会报错。 在我们项目的根目录下找到 node_modules/element-plus/theme-chalk/src/common/var.scss 这个文件，这里面所有后面带有 !default 的就是我们可以修改的所有的 scss 的变量了 比如说我们想要修改一下 primary 的样式，我们查找 var.scss 文件发现，关于 primary 颜色的定义就在第 21 行，$--colors 的初始值就是带有 !default 的， 我们在 element-variables.scss 文件中对 $--colors 重新赋值就可以修改 primary 的颜色 src/theme/element-variables.scss 12345$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: #000, ),); 注意：要通过修改scss变量的方式自定义主题，必须重新设置 font 文件路径 引入 element-plus/packages/theme-chalk/src/index.scss 之后，就可以修改 scss 的变量了 所以我们在 src/theme 文件夹下在新建一个 index.scss 文件，用来引入自定义的主题并处理 font 路径和 element-plus 的 scss 文件 src/theme/index.scss 123@import &quot;./element-variables.scss&quot;;$--font-path: &quot;~element-plus/theme-chalk/fonts&quot;; @import &quot;~element-plus/packages/theme-chalk/src/index&quot;; 在 src/theme/index.ts 文件中引入这个文件 import &quot;./index.scss&quot;; src/theme/index.ts 1234567891011import &#123; App &#125; from &quot;vue&quot;;import &quot;dayjs/locale/zh-cn&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;import &quot;./index.scss&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; 删除 src.main.ts 中引入样式的代码 import &quot;element-plus/dist/index.css&quot;; 刷新浏览器就可以看到我们修改的主题的样式了 配置 scss 全局变量文件在我们的项目开发过程中，不可能只使用 element-plus 的组件和样式，所以我们会需要维护一套我们自己的 scss ，为了样式的统一和以后的好维护，我们应该使用和 element-plus 类似的这种全局变量的方式，定义我们的统一的颜色、边框等等 在 src/assets 目录下新建一个 scss 文件夹，在其中新建以下文件 var.scss 定义全局的变量 mixin.scss 定义全局的混入 fun.scss 定义全局的函数 common.scss 全局的样式，这个文件会定义一些具体的选择器的样式，上面的其他文件中定义都是不会被直接编译出 css 代码的 在 sass-loader中配置成全局scss文件在项目根目录下创建 vue.config.js 文件，并添加 css 配置 vue.config.js 1module.exports = &#123; css: &#123; loaderOptions: &#123; scss: &#123; additionalData: ` @import &quot;~@/assets/scss/var.scss&quot;; @import &quot;~@/assets/scss/mixin.scss&quot;; @import &quot;~@/assets/scss/fun.scss&quot;; `, &#125;, &#125;, &#125;,&#125;; 验证一下全局的 scss 文件是否配置成功 在 src/assets/scss/var.sass 中添加变量 $primary-color: red;，把刚才修改的 src/theme/element-variables 文件中的 primary 的颜色设置成 $primary-color src/assets/scss/var.scss 1$primary-color: red; src/theme/element-variables.scss 1$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: $primary-color, ),); 在 src/assets/scss/fun.scss 文件中添加一个 toRem 函数，在 src/App.vue 中调用这个函数 在 src/App.vue 中添加一个标签 &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt;，在 style 标签里给 div 定义一个样式，使用 $primary-color 变量和 toRem 函数 src/assets/scss/fun.scss 1@function toRem($px) &#123; @return $px / 75px * 1rem;&#125; 实际开发中，如果有需要 px 转 rem 的操作，建议可以使用 postcss 的插件 pxtorem ，可以不用每次都要都要写 toRem()，这里只是用来做一下演示 src/App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 省略其余代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script&gt; // ... 省略js代码&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.bg-red &#123; width: toRem(200px); height: toRem(200px); background: $primary-color;&#125;&lt;/style&gt; 在项目编译的时候给出了以下警告，使用 / 表示除法已经被废弃，应该使用 math.div 方法 修改一下 src/assets/scss/fun.scss 文件 1234@use &quot;sass:math&quot;;@function toRem($px) &#123; @return math.div($px, 75px) * 1rem;&#125; 打开浏览器可以看到红色的按钮，和 div 的样式，宽高已经是 rem 的单位，并且背景也红色 最后，在 src/main.ts 中引入 common.scss 文件 1import &quot;@/assets/scss/common.scss&quot;; 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：配置运行环境","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第一篇-使用vue-cli 创建Vue3项目","slug":"第一篇-使用vue-cli 创建Vue3项目","date":"2021-09-06T06:24:36.000Z","updated":"2021-09-07T12:40:00.083Z","comments":true,"path":"2021/09/06/第一篇-使用vue-cli 创建Vue3项目/","link":"","permalink":"https://wukang0718.com/2021/09/06/%E7%AC%AC%E4%B8%80%E7%AF%87-%E4%BD%BF%E7%94%A8vue-cli%20%E5%88%9B%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"第一步：安装 nodejs安装已经安装可以跳过到 下一步 nodejs 官网地址：https://nodejs.org/zh-cn/download/ 长期维护版（即稳定版）下选择对应的操作系统点击即可下载，之后一直点击下一步，即可完成安装 安装完成后检查是否安装成功打开命令行窗口 windows系统使用win+R，之后输入 cmd mac 用户，打开 terminal / 终端 输入 node -v 查看 nodejs 版本，输入 npm -v 查看 npm 版本 1234node -v# v14.17.4npm -v# 7.21.1 显示对应的版本就表示安装成功 第二步：安装vue-cli安装已经安装可以跳过到 下一步 vue-cli 官网：https://cli.vuejs.org/zh/guide/installation.html 建议全局安装 在命令行执行以下命令，mac用户需要 sudo 执行 123npm install -g @vue/cli# ORyarn global add @vue/cli 安装完成后检查是否安装成功命令行执行 vue --version 12vue --version# @vue/cli 4.5.13 看到正确的版本号，表示安装成功 第三步：使用脚手架创建项目在命令行执行 vue create &lt;app-name&gt; 命令创建项目，例如，我现在创建一个名叫 cli-create-project 的项目，在命令执行 1vue create cli-create-project 选择 preset 命令行窗口会提示请选择一个 preset，建议选择第三个 Manually select features，选择第一个或者第二个，创建的项目会比较简陋，只有 babel 和 eslint ，项目中必备的 vue-router 等的不会被创建，选择第三项（手动选择功能）,按上下键选择，回车键确认，进入下一步 选择功能 回车之后，命令行窗口就到了选择功能，按上下键切换功能，空格选中和取消选中，回车会进入到下一步。 Choose Vue version 必选，之后会选择使用Vue2还是Vue3 Babel 必选 TypeScript 选中之后，项目会安装typescript的依赖，建议是Vue2的话，就不用选了，Vue3的还是可以使用TypeScript的 Progressive Web App (PWA) Support 可选可不选，在项目中添加pwa支持， 会在项目中添加 Service Workers Router 必选，在项目中安装 vue-router Vuex 按照项目的需求来，会在项目中安装 vuex，一般不是很小的项目的话，都会用到的 CSS Pre-processors 一般都选，安装css的预处理器 Linter / Formatter 必选，安装 eslint 和一个格式化代码的工具会校验和格式化代码 Unit Testing 集成单元测试，看自己情况安装吧 E2E Testing 集成端到端测试，也是看自己情况安装吧 回车进入下一步 选择 vue 版本，这里选择3.x 回车进入下一步 选择是否使用类组件语法，Vue3的话就使用不了，输入 n 回车 选择是否使用Babel与TypeScript一起用于自动检测的填充，使用，输入 Y 回车 选择是否使用 history 模式的路由，是否都是可以的，我就选择使用，输入 Y 回车 选择一个 css 的预处理器，这里按照个人的喜好选择吧，我后续要添加 element-plus 的UI框架，所以就选择 Sass/SCSS (with dart-sass)，回车到下一步 选择一个 lint 和 一个格式化代码的工具，我比较喜欢用 ESLint + Prettier ，就选择这个了,回车到下一步 选择 lint 执行的时机，在保存时执行，或者是在代码提交的时候，需要自动修复，我不需要自动修复，就选择 Lint on save 了，回车到下一步 选择一个单元测试的工具，我用 Jest 比较多，这里就选择 jest，如果在第二步的时候，没有选择 Unit Testing ，就没有这一步 选择一个端到端的测试框架，同样我用 Cypress，比较多，我就选择这个了，同样的，如果在第二步的时候，没有选择 E2E Testing，就没有这一步 选择一个存放插件（eslint、postcss、babel…）配置文件的位置 In dedicated config files 存放在单独的配置文件中，会在项目目录下生成 babel.config.js 之类的文件 In package.json 把插件的配置都写在 packgae.json 文件中 个人喜欢单独文件存放，就选择 In dedicated config files 了，回车到下一步 是否要把这些配置保存为一个将来可复用的 preset。 选择 Y 的话，会把 preset 保存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。 不想保存的话就输入n，回车开始下载项目模版并安装依赖 安装完成，进入项目目录 1cd cli- create-project 这里默认安装的 vue、vue-router 、vuex 的版本都比较低，先升级一下版本 123npm install vue@next vue-router@next vuex@next --save#or yarn add vue@next vue-router@next vuex@next --save 升级完版本之后，运行项目看一下是否可以成功运行 123npm run serve#oryarn serve 启动成功 在浏览器访问 使用 vue-cli 创建 vue3 项目就成功了 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：在项目中添加 element-plus","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"vue-router中query参数做自动加密、解密","slug":"vue-router中query参数做自动加密、解密","date":"2021-09-04T10:46:27.000Z","updated":"2021-09-07T12:50:21.685Z","comments":true,"path":"2021/09/04/vue-router中query参数做自动加密、解密/","link":"","permalink":"https://wukang0718.com/2021/09/04/vue-router%E4%B8%ADquery%E5%8F%82%E6%95%B0%E5%81%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/","excerpt":"","text":"vue-router 插件，对vue-router使用中query参数做自动加密、解密仓库地址​ github: https://github.com/wukang0718/vueRouterEncryption ​ gitee: https://gitee.com/wu_kang0718/vueRouterEncryption 使用方式 加密需要依赖 crypto-js 库，安装： npm 1npm install crypto-js --save yarn 1yarn add crypto-js 将utils文件夹放入项目 （最好是放在router目录下 ） 中，在router的初始化文件中，引入utils/query.js的stringifyQuery和parseQuery方法，在new VueRouter是时候传递参数， 修改utils/encryption.js中的baseCryptoCode设置每个项目唯一的值 例：（参考index.js） 1234567891011121314151617import Vue from &quot;vue&quot;import VueRouter from &quot;vue-router&quot;;import &#123; stringifyQuery, parseQuery &#125; from &quot;./utils/query&quot;;Vue.use(VueRouter);const routes = [];const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, stringifyQuery: stringifyQuery, // 序列化query参数 parseQuery: parseQuery, // 反序列化query参数 routes&#125;);export default router 结构 utils/encryption.js 文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js） getEncrypt 加密 对应的解密方法（getDecrypt） getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64） getDecrypt 解密 对应的加密方法（getEncrypt） getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64） utils/query.js 文件提供了序列化和反序列化的方法 stringifyQuery 序列化对象并 加密 parseQuery 解密 反序列化对象 原理 在创建路由的时候，添加两个方法 stringifyQuery: 序列化传入的query参数，方法可以接收一个对象参数 在new Router的时候传递这个属性，在序列化query参数的就执行这个方法，不会执行默认的方法，序列化后在地址栏显示序列化之后的参数 parseQuery: 解析地址栏参数，方法接收一个字符串参数 在new Router的时候传递这个属性，在解析query参数的时候，回执行这个方法，不会在执行默认的方法， 注： 这个方法只解析path中的参数，或者浏览器刷新的时候的地址栏的参数，不会对在query参数对处理，如： 123456this.$router.push(&#123; path: &quot;foo?a=123&quot;, query: &#123; b: 345 &#125;&#125;) 在执行这段代码的时候，parseQuery方法不会对query:&#123;b: 345&#125;进行解析,会解析path:&quot;foo?a=123&quot;中的a=123的字符串 序列化 vue-router在执行createRoute的时候，获取fullPath会执行getFullPath方法 createRouter 方法 会获取在 new VueRouter的时候传递的stringifyQuery方法，如果没有这个方法，就会在getFullPath的时候，使用默认的方法 源码位置：“/vue-router/src/utils/route.js” 12345678910111213141516171819202122232425262728export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || &#x27;/&#x27;, hash: location.hash || &#x27;&#x27;, query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125; getFullPath 方法接收两个参数（路由对象， 序列化query的方法） 源码： 1234567function getFullPath ( &#123; path, query = &#123;&#125;, hash = &#x27;&#x27; &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || &#x27;/&#x27;) + stringify(query) + hash&#125; 反序列化 在调用push的时候，会执行this.router.match方法，match方法会执行normalizeLocation normalizeLocation通过resolveQuery方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法） 反序列化方法会通过router &amp;&amp; router.options.parseQuery获取，如果在new VueRouter的时候传递了parseQuery方法，就是用该方法，如果没有就在resolveQuery方法中使用默认的方法 源码地址：“/vue-router/src/utils/location.js” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === &#x27;string&#x27; ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; return next &#125; else if (next.name) &#123; next = extend(&#123;&#125;, raw) const params = next.params if (params &amp;&amp; typeof params === &#x27;object&#x27;) &#123; next.params = extend(&#123;&#125;, params) &#125; return next &#125; // relative params if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; const parsedPath = parsePath(next.path || &#x27;&#x27;) const basePath = (current &amp;&amp; current.path) || &#x27;/&#x27; const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== &#x27;#&#x27;) &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125;","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"}]},{"title":"为什么微任务比宏任务执行快","slug":"为什么微任务比宏任务执行快","date":"2021-09-04T07:49:41.000Z","updated":"2021-09-07T12:50:13.765Z","comments":true,"path":"2021/09/04/为什么微任务比宏任务执行快/","link":"","permalink":"https://wukang0718.com/2021/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BF%AB/","excerpt":"","text":"为什么微任务比宏任务执行快 微任务叫 microtask 称为 jobs，是由JavaScript自身发起的 宏任务叫 macrotask 称为 task，是由宿主环境发起的 Event Loop中，每一次循环称为tick 主要区别 宏任务（macrotask） 微任务（microtask） 谁发起的 Nodejs/浏览器 JavaScript自身 具体事件 script 标签setTimeout/setIntervalUiRenderingpostMessage/messageChannelsetImmediate/IO PromiseMutationObserverprocess.nextTick 谁先执行 后执行 先执行 会触发新一轮的tick吗 会 不会","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"},{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"},{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}