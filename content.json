{"meta":{"title":"前端武康","subtitle":"","description":"前端博客 Vue React Node","author":"武康","url":"https://wukang0718.com","root":"/"},"pages":[{"title":"关于","date":"2021-08-30T05:54:04.000Z","updated":"2021-08-30T05:54:20.896Z","comments":true,"path":"about/index.html","permalink":"https://wukang0718.com/about/","excerpt":"","text":""},{"title":"分类","date":"2021-08-30T05:48:12.000Z","updated":"2021-08-30T05:53:39.290Z","comments":true,"path":"categories/index.html","permalink":"https://wukang0718.com/categories/","excerpt":"","text":""},{"title":"标签","date":"2021-08-30T05:51:09.000Z","updated":"2021-08-30T05:56:35.571Z","comments":true,"path":"tags/index.html","permalink":"https://wukang0718.com/tags/","excerpt":"","text":""}],"posts":[{"title":"ref源码","slug":"ref源码","date":"2022-09-02T09:00:25.000Z","updated":"2022-09-02T09:00:57.125Z","comments":true,"path":"2022/09/02/ref源码/","link":"","permalink":"https://wukang0718.com/2022/09/02/ref%E6%BA%90%E7%A0%81/","excerpt":"","text":"ref 方法 源码地址：https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/ref.ts 接收一个参数，返回参数的深代理，如果参数是对象，.value 是 reactive 的值 123export function ref(value?: unknown) &#123; return createRef(value)&#125; shallowRef 方法接收一个参数，返回 对参数 浅代理 123export function shallowRef(value?: unknown) &#123; return createRef(value, true)&#125; 调用 createRef 方法 createRef 方法判断如果已经是 ref 对象，直接返回这个对象 否则，返回一个 RefImpl 类型的实例 123456function createRef(rawValue: unknown, shallow = false) &#123; if (isRef(rawValue)) &#123; // 判断是否已经是 ref 对象 return rawValue &#125; return new RefImpl(rawValue, shallow)&#125; RefImpl 类new 接收两个参数 参数 描述 _rawValue 原始值 _shallow 是否只做浅层的代理，默认值 false 做 深层 的代理 实例属性： 属性 描述 _value 原始值 __v_isRef ref 对象的表示，在判断对象是不是 ref 对象的时候，会用到 _rawValue 原始值 或 修改后的原始值 _shallow 是否只做浅层的监听 value 暴露给外层访问的属性，会调用 get、set 方法 1234567891011121314151617181920212223class RefImpl&lt;T&gt; &#123; private _value: T public readonly __v_isRef = true constructor(private _rawValue: T, public readonly _shallow = false) &#123; this._value = _shallow ? _rawValue : convert(_rawValue) // convert 函数做深层的代理 &#125; get value() &#123; track(toRaw(this), TrackOpTypes.GET, &#x27;value&#x27;) // track 函数收集依赖，后续描述 return this._value &#125; set value(newVal) &#123; // hasChanged 方法会对 NaN 做处理 if (hasChanged(toRaw(newVal), this._rawValue)) &#123; // 如果修改后的值，和当前值不一致 this._rawValue = newVal this._value = this._shallow ? newVal : convert(newVal) trigger(toRaw(this), TriggerOpTypes.SET, &#x27;value&#x27;, newVal) // trigger 函数触发依赖，后续描述 &#125; &#125;&#125; convert 函数接收一个参数，如果参数是对象/数组类型，调用 reactive 方法，否则返回参数本身 12const convert = &lt;T extends unknown&gt;(val: T): T =&gt; isObject(val) ? reactive(val) : val 示例： 123456setup() &#123; const ref0 = Vue.ref(&#123;a: 1&#125;) const ref1 = Vue.shallowRef(&#123;a: 1&#125;) console.log(ref0); // &#123;..., value: Proxy&#123;a: 1&#125;&#125; console.log(ref1); // &#123;..., value: Object&#123;a: 1&#125;&#125;&#125; isRef 方法方法接收一个参数，返回 boolean，判断参数是不是 ref 类型 123export function isRef(r: any): r is Ref &#123; return Boolean(r &amp;&amp; r.__v_isRef === true)&#125; 示例： 123456setup() &#123; const ref = Vue.ref(0) console.log(isRef(ref)); // true console.log(isRef(0)); // false console.log(isRef(&#123;__v_isRef: true&#125;)) // true&#125; triggerRef 方法方法接收一个 ref 对象，触发这个 ref 对象上收集的依赖 123export function triggerRef(ref: Ref) &#123; trigger(toRaw(ref), TriggerOpTypes.SET, &#x27;value&#x27;, __DEV__ ? ref.value : void 0)&#125; 示例： 1234567setup() &#123; const ref = Vue.ref(0) Vue.watchEffect(() =&gt; &#123; // watchEffect 默认会收集依赖 console.log(ref.value); // 0 &#125;) Vue.triggerRef(ref) // 0&#125; unref 方法方法接收一个参数，如果参数是 ref 类型，返回 .value 的值，否则返回参数自己 123export function unref&lt;T&gt;(ref: T): T extends Ref&lt;infer V&gt; ? V : T &#123; return isRef(ref) ? (ref.value as any) : ref&#125; 示例： 12345setup() &#123; const ref = Vue.ref(0) console.log(Vue.unref(ref)) // 0 console.log(Vue.unref(0)) // 0&#125; proxyRefs 方法方法接收一个参数，返回一个 proxy 对象 这个方法返回的 proxy 对象，不会触发依赖的收集和触发 12345678export function proxyRefs&lt;T extends object&gt;( objectWithRefs: T): ShallowUnwrapRef&lt;T&gt; &#123; return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers)&#125; proxy 的 handle 是 shallowUnwrapHandlers get 返回数据的原值 set 方法针对代理对象的类型做修改 123456789101112const shallowUnwrapHandlers: ProxyHandler&lt;any&gt; = &#123; get: (target, key, receiver) =&gt; unref(Reflect.get(target, key, receiver)), set: (target, key, value, receiver) =&gt; &#123; const oldValue = target[key] if (isRef(oldValue) &amp;&amp; !isRef(value)) &#123; oldValue.value = value return true &#125; else &#123; return Reflect.set(target, key, value, receiver) &#125; &#125;&#125; 示例： 123setup() &#123; console.log(Vue.proxyRefs(&#123;a: 12&#125;)) // Proxy&#123;a: 12&#125;&#125; customRef 方法自定义 ref 类型，接收一个函数，函数可以接收两个参数 track Function 调用可以收集依赖 trigger Function 调用可以派发依赖 函数需要返回一个对象，对象需要包含 get 和 set 方法，如果需要响应式，应该在 get 方法中调用 track ，在 set 方法中调用 trigger get Function 在获取返回值的 .value 时调用 set Function 在设置返回值的 .value 时调用 123export function customRef&lt;T&gt;(factory: CustomRefFactory&lt;T&gt;): Ref&lt;T&gt; &#123; return new CustomRefImpl(factory) as any&#125; 返回了一个 CustomRefImpl 实例 CustomRefImpl 类1234567891011121314151617181920212223class CustomRefImpl&lt;T&gt; &#123; private readonly _get: ReturnType&lt;CustomRefFactory&lt;T&gt;&gt;[&#x27;get&#x27;] private readonly _set: ReturnType&lt;CustomRefFactory&lt;T&gt;&gt;[&#x27;set&#x27;] public readonly __v_isRef = true constructor(factory: CustomRefFactory&lt;T&gt;) &#123; const &#123; get, set &#125; = factory( () =&gt; track(this, TrackOpTypes.GET, &#x27;value&#x27;), () =&gt; trigger(this, TriggerOpTypes.SET, &#x27;value&#x27;) ) this._get = get this._set = set &#125; get value() &#123; return this._get() &#125; set value(newVal) &#123; this._set(newVal) &#125;&#125; 示例： 1234567891011121314151617181920212223242526272829303132333435Vue.createApp(&#123; template: &quot;#item-template&quot;, setup() &#123; const text = useDebouncedRef(&quot;123&quot;) Vue.watchEffect(() =&gt; &#123; console.log(text.value) console.timeEnd(&quot;input&quot;) &#125;) console.time(&quot;input&quot;) text.value = &quot;345&quot; return &#123; text &#125; &#125;&#125;).use(ElementPlus).mount(&quot;#app&quot;)// customRef 实现防抖函数function useDebouncedRef(value, delay = 200) &#123; let timer; return Vue.customRef((track, trigger) =&gt; (&#123; get() &#123; track(); return value &#125;, set(val) &#123; timer &amp;&amp; clearTimeout(timer); if (value !== val) &#123; timer = setTimeout(() =&gt; &#123; value = val; trigger(); timer = null; &#125;, delay) &#125; &#125; &#125;))&#125; toRef 方法返回对象的 key 对应的值，返回的是一个具有 value 属性的对象 12345678export function toRef&lt;T extends object, K extends keyof T&gt;( object: T, key: K): ToRef&lt;T[K]&gt; &#123; return isRef(object[key]) ? object[key] : (new ObjectRefImpl(object, key) as any)&#125; ObjectRefImpl 类返回一个具有 value 属性的对象，这个对象不会收集依赖和触发依赖 12345678910111213class ObjectRefImpl&lt;T extends object, K extends keyof T&gt; &#123; public readonly __v_isRef = true constructor(private readonly _object: T, private readonly _key: K) &#123;&#125; get value() &#123; return this._object[this._key] &#125; set value(newVal) &#123; this._object[this._key] = newVal &#125;&#125; 示例： 123456789setup() &#123; const b = Vue.ref(12) const text = &#123; a: 12, b: Vue.ref(12) &#125; console.log(Vue.toRef(text, &quot;a&quot;)) // ObjectRefImpl console.log(Vue.toRef(text, &quot;b&quot;)) // RefImpl&#125; toRefs 方法接收一个对象，返回一个新的对象， 这个对象的每一个属性都是一个具有 value 属性的对象，这个方法只做一层代理，没有深度遍历，且不会收集依赖和触发依赖 12345678910export function toRefs&lt;T extends object&gt;(object: T): ToRefs&lt;T&gt; &#123; if (__DEV__ &amp;&amp; !isProxy(object)) &#123; console.warn(`toRefs() expects a reactive object but received a plain one.`) &#125; const ret: any = isArray(object) ? new Array(object.length) : &#123;&#125; for (const key in object) &#123; ret[key] = toRef(object, key) &#125; return ret&#125; 示例： 123456789setup() &#123; const text = &#123; a: 12, b: Vue.ref(12) &#125; const refs = Vue.toRefs(text); console.log(refs.a) // ObjectRefImpl console.log(refs.b) // RefImpl&#125;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"ref","slug":"ref","permalink":"https://wukang0718.com/tags/ref/"}]},{"title":"reactive源码","slug":"reactive源码","date":"2022-09-02T08:59:27.000Z","updated":"2022-09-02T08:59:54.688Z","comments":true,"path":"2022/09/02/reactive源码/","link":"","permalink":"https://wukang0718.com/2022/09/02/reactive%E6%BA%90%E7%A0%81/","excerpt":"","text":"源码位置： https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/reactive.ts reactive 方法接收一个对象，返回 对象深代理，通过 createReactiveObject 方法 对象的 reactive 代理，会被缓存，所以对同一个对象执行多次 reactive 返回的是同一个值 示例： 123456setup() &#123; const a = &#123;b: 12&#125; const reactive1 = Vue.reactive(a) const reactive2 = Vue.reactive(a) console.log(reactive1 === reactive2) // true&#125; 如果对象是 readonly 类型的，就返回对象本身 示例： 123456setup() &#123; const a = &#123;b: 12&#125; const readonly = Vue.readonly(a) const reactive = Vue.reactive(readonly) console.log(readonly === reactive) // true&#125; 1234567891011export function reactive(target: object) &#123; if (target &amp;&amp; (target as Target)[ReactiveFlags.IS_READONLY]) &#123; return target &#125; return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers )&#125; mutableHandlers在 target 是一个正常的 Object 或者 Array 时，使用这个对象做 proxy 的 handle 1234567891011121314151617181920212223242526272829303132333435363738394041const get = /*#__PURE__*/ createGetter() // 在下面const set = /*#__PURE__*/ createSetter() // 在下面// delete / Reflect.deleteProperty() 操作符的时候调用function deleteProperty(target: object, key: string | symbol): boolean &#123; const hadKey = hasOwn(target, key) // Object.prototype.hasOwnProperty const oldValue = (target as any)[key] const result = Reflect.deleteProperty(target, key) if (result &amp;&amp; hadKey) &#123; // 如果删除成功，触发依赖更新 trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue) &#125; return result&#125;// in / Reflect.has() 操作符调用function has(target: object, key: string | symbol): boolean &#123; const result = Reflect.has(target, key) if (!isSymbol(key) || !builtInSymbols.has(key)) &#123; // key 和 value 不是 symbol 类型 收集依赖 track(target, TrackOpTypes.HAS, key) &#125; return result&#125;/** 拦截下面操作 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() Reflect.ownKeys() */function ownKeys(target: object): (string | number | symbol)[] &#123; track(target, TrackOpTypes.ITERATE, isArray(target) ? &#x27;length&#x27; : ITERATE_KEY) return Reflect.ownKeys(target)&#125;export const mutableHandlers: ProxyHandler&lt;object&gt; = &#123; get, set, deleteProperty, has, ownKeys&#125; createGetter参数接收 isReadonly 是否只读， shallow 是否只做前代理， 返回一个 get 函数 当返回值时一个对象，并且 shallow 为 false 时，会对返回值再做一次 readonly 或者 reactive 处理，实现深代理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 返回一个 get 函数 * @param isReadonly 只读 * @param shallow 浅代理 */function createGetter(isReadonly = false, shallow = false) &#123; return function get(target: Target, key: string | symbol, receiver: object) &#123; if (key === ReactiveFlags.IS_REACTIVE) &#123; // 这个key __v_isReactive 表示对象是不是 reactive 类型 return !isReadonly &#125; else if (key === ReactiveFlags.IS_READONLY) &#123; // 这个key __v_isReadonly 表示对象是不是只读类型 return isReadonly &#125; else if ( key === ReactiveFlags.RAW &amp;&amp; receiver === (isReadonly ? readonlyMap : reactiveMap).get(target) ) &#123; // 这个keym __v_raw 获取 代理的源对象 return target &#125; // 上面的三个 特殊值，在 is 开头的函数 和 to 开头的函数中用到 // 例：isReactive / toRaw const targetIsArray = isArray(target) // 不是只读，是数组，并且调用了数组的方法，需要特殊的方法处理 if (!isReadonly &amp;&amp; targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) &#123; return Reflect.get(arrayInstrumentations, key, receiver) &#125; const res = Reflect.get(target, key, receiver) // key 是 symbol 类型，并且值也是 symbol 或者 获取的是 __proto__ 或者 __v_isRef 时 // 直接返回结果 if ( isSymbol(key) ? builtInSymbols.has(key as symbol) : key === `__proto__` || key === `__v_isRef` ) &#123; return res &#125; // 不是只读的数据，收集依赖 if (!isReadonly) &#123; track(target, TrackOpTypes.GET, key) &#125; // 浅代理，返回结果 if (shallow) &#123; return res &#125; if (isRef(res)) &#123; // ref展开-不适用于数组 和 整数键。 const shouldUnwrap = !targetIsArray || !isIntegerKey(key) // 这里对 ref 做了 返回原始值的处理 return shouldUnwrap ? res.value : res &#125; // 如果结果时对象，对这个对象在做一次 reactive 处理，实现深代理 if (isObject(res)) &#123; // Convert returned value into a proxy as well. we do the isObject check // here to avoid invalid value warning. Also need to lazy access readonly // and reactive here to avoid circular dependency. return isReadonly ? readonly(res) : reactive(res) &#125; return res &#125;&#125; 这里用到了一个特殊的值 arrayInstrumentations 这个值表示需要特殊处理的 Array 的方法 1234567891011121314151617181920212223242526272829303132/** * 数组的一些方法需要做特殊的处理 */const arrayInstrumentations: Record&lt;string, Function&gt; = &#123;&#125;;([&#x27;includes&#x27;, &#x27;indexOf&#x27;, &#x27;lastIndexOf&#x27;] as const).forEach(key =&gt; &#123; const method = Array.prototype[key] as any arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) &#123; const arr = toRaw(this) // 获取到数组的原值 for (let i = 0, l = this.length; i &lt; l; i++) &#123; // 循环对数组中的每一项添加依赖 track(arr, TrackOpTypes.GET, i + &#x27;&#x27;) &#125; // 先不对参数做处理，直接运行方法 const res = method.apply(arr, args) if (res === -1 || res === false) &#123; // 如果方法没有期望的返回值，在对参数做一次 toRaw（获取原始值） 转换 return method.apply(arr, args.map(toRaw)) &#125; else &#123; return res &#125; &#125;&#125;)// 这些方法会改变 Array 的length 属性，在某种情况下，会导致依赖循环触发 #2137;([&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;] as const).forEach(key =&gt; &#123; const method = Array.prototype[key] as any arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) &#123; pauseTracking() // 停止依赖收集 const res = method.apply(this, args) // 获取到处理结果 resetTracking() // 恢复依赖收集 return res &#125;&#125;) createSetter函数接收一个参数 shallow ，是否只做浅代理，返回一个 set 函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 返回一个 set 方法 * @param shallow 是否做浅代理操作 */function createSetter(shallow = false) &#123; return function set( target: object, key: string | symbol, value: unknown, receiver: object ): boolean &#123; const oldValue = (target as any)[key] if (!shallow) &#123; value = toRaw(value) // 深代理模式下，如果数组中的每一项都是 ref 对象，修改只修改该项的 value 值，不替换整个对象 if (!isArray(target) &amp;&amp; isRef(oldValue) &amp;&amp; !isRef(value)) &#123; oldValue.value = value return true &#125; &#125; else &#123; // in shallow mode, objects are set as-is regardless of reactive or not &#125; // 判断 key 是数组的下标或者 对象/数组的属性 const hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? Number(key) &lt; target.length : hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) // don&#x27;t trigger if target is something up in the prototype chain of original // 不能直接触发依赖更新，有可能是原型链上的proxy被调用 // 要判断 receiver 的原始值，就是当前的target对象， 这样确保是当前的 target 的 proxy 被触发 if (target === toRaw(receiver)) &#123; // if (!hadKey) &#123; // 没有 key 的情况是添加属性，或者 数组添加一项 trigger(target, TriggerOpTypes.ADD, key, value) &#125; else if (hasChanged(value, oldValue)) &#123; // 有 key 并且 新旧值不一样，修改成功，需要触发 set 的依赖 trigger(target, TriggerOpTypes.SET, key, value, oldValue) &#125; &#125; return result &#125;&#125; mutableCollectionHandlers123export const mutableCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123; get: createInstrumentationGetter(false, false)&#125; createInstrumentationGetter接收两个参数 isReadonly 是否只读和 shallow 是否浅代理 返回一个 get 方法，这里是对 Map. 的代理，get 方法中对 set/has…方法做了处理，通过 instrumentations 对象 123456789101112131415161718192021222324252627282930313233343536/** * 返回一个 Collection 的get 函数，在 get 中，对 set/has... 方法做处理 * @param isReadonly 是否只读 * @param shallow 是否浅代理 */function createInstrumentationGetter(isReadonly: boolean, shallow: boolean) &#123; const instrumentations = shallow ? shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations return ( target: CollectionTypes, key: string | symbol, receiver: CollectionTypes ) =&gt; &#123; if (key === ReactiveFlags.IS_REACTIVE) &#123; return !isReadonly &#125; else if (key === ReactiveFlags.IS_READONLY) &#123; return isReadonly &#125; else if (key === ReactiveFlags.RAW) &#123; return target &#125; // 处理三个特殊 key 在 is... 和 to... 的方法中用到 // 如果是 instrumentations 中有的方法，并且是 target 中的原始存在的方法，就使用代理，否则直接放回对象本身的值 return Reflect.get( hasOwn(instrumentations, key) &amp;&amp; key in target ? instrumentations : target, key, receiver ) &#125;&#125; instrumentations =&gt; mutableInstrumentations返回了一个 handle 的对象，对象方法中的 this，都是指向 reactive 对象 12345678910111213141516171819202122const mutableInstrumentations: Record&lt;string, Function&gt; = &#123; get(this: MapTypes, key: unknown) &#123; return get(this, key) &#125;, get size() &#123; return size((this as unknown) as IterableCollections) &#125;, has, add, set, delete: deleteEntry, clear, forEach: createForEach(false, false)&#125;const iteratorMethods = [&#x27;keys&#x27;, &#x27;values&#x27;, &#x27;entries&#x27;, Symbol.iterator]iteratorMethods.forEach(method =&gt; &#123; mutableInstrumentations[method as string] = createIterableMethod( method, false, false )&#125;) get代理 get 方法 12345678910111213141516171819202122232425262728293031/** * 获取值的方法 * @param proxy 对象 reactive 对象 * @param key 获取的key * @param isReadonly 是否只读 * @param isShallow 是否浅代理 */function get( target: MapTypes, key: unknown, isReadonly = false, isShallow = false) &#123; target = (target as any)[ReactiveFlags.RAW] // 获取到原始值 （可能是 reactive 对象） #1772 const rawTarget = toRaw(target) // 获取到最终的原始值 const rawKey = toRaw(key) // 获取 key 的原始值 if (key !== rawKey) &#123; // 如果 key 是 reactive 类型，且代理不是 readonly ，收集 key 的依赖 !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, key) &#125; // 再次收集一次依赖 ??? !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.GET, rawKey) const &#123; has &#125; = getProto(rawTarget) const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive // 先获取 key 不是 reactive 的情况 if (has.call(rawTarget, key)) &#123; return wrap(target.get(key)) &#125; else if (has.call(rawTarget, rawKey)) &#123; return wrap(target.get(rawKey)) &#125;&#125; toReactive获取到最终要返回的值的方法，如果是对象/数组类型，返回一个 reactive 类型，否则返回原始值 12const toReactive = &lt;T extends unknown&gt;(value: T): T =&gt; isObject(value) ? reactive(value) : value size拦截 .size 的获取 123456789101112/** * 拦截 .size 的获取 * @param proxy 对象 reactive 对象 * @param isReadonly 是否只读 */function size(target: IterableCollections, isReadonly = false) &#123; target = (target as any)[ReactiveFlags.RAW] // 不是 只读 收集依赖 !isReadonly &amp;&amp; track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY) // 返回原始的 size 属性 return Reflect.get(target, &#x27;size&#x27;, target)&#125; has拦截 has 操作 123456789101112131415161718192021/** * 拦截 has 操作 * @param proxy 对象 reactive 对象 * @param key 判断的key * @param isReadonly 是否只读 */function has(this: CollectionTypes, key: unknown, isReadonly = false): boolean &#123; const target = (this as any)[ReactiveFlags.RAW] // 获取原始值，可能是一个 reactive 对象 const rawTarget = toRaw(target) // 获取到最终的原始值 const rawKey = toRaw(key) // 获取到 key 的原始值 if (key !== rawKey) &#123; // key 是 reactive 类型时，收集 key 的依赖 !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.HAS, key) &#125; // 收集 rawKey 的依赖 !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.HAS, rawKey) // 先 判断 有没有 reactive 的 key 的值，然后判断 原始值的 key 的值 return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey)&#125; add拦截 Set/WeakSet 的 add 操作 1234567891011121314151617/** * 拦截 Set/WeakSet 的 add 操作 * @param proxy 对象 reactive 对象 * @param value 添加的数据 */function add(this: SetTypes, value: unknown) &#123; value = toRaw(value) // 获取到 value 的原始值 const target = toRaw(this) // 获取 target 的原始值 const proto = getProto(target) // 获取原型 const hadKey = proto.has.call(target, value) target.add(value) // 给 set 中添加原始值 if (!hadKey) &#123; // 如果 set 中之前没有这个值，触发一次依赖 trigger(target, TriggerOpTypes.ADD, value, value) &#125; return this&#125; set拦截 Map 和 WeakMap 的操作 12345678910111213141516171819202122232425262728293031/** * 拦截 Map 和 WeakMap 的操作 * @param proxy 对象 reactive 对象 * @param key key * @param value value */function set(this: MapTypes, key: unknown, value: unknown) &#123; value = toRaw(value) // 获取到 value 的原始值 const target = toRaw(this) // 获取到 target 的原始值 const &#123; has, get &#125; = getProto(target) let hadKey = has.call(target, key) // boolean 元数据是否存在 key if (!hadKey) &#123; key = toRaw(key) // key 的原始值 hadKey = has.call(target, key) // 如果没有 reactive 的key ，尝试获取 原始类型的key 是否存在 &#125; else if (__DEV__) &#123; // 开发环境做的操作，忽略 checkIdentityKeys(target, has, key) &#125; const oldValue = get.call(target, key) target.set(key, value) if (!hadKey) &#123; // 触发一次 添加的依赖 trigger(target, TriggerOpTypes.ADD, key, value) &#125; else if (hasChanged(value, oldValue)) &#123; // 触发一次修改的依赖 trigger(target, TriggerOpTypes.SET, key, value, oldValue) &#125; return this&#125; delete拦截 delete 操作 123456789101112131415161718192021222324/** * 拦截 delete 操作 * @param proxy 对象 reactive 对象 * @param key key */function deleteEntry(this: CollectionTypes, key: unknown) &#123; const target = toRaw(this) const &#123; has, get &#125; = getProto(target) let hadKey = has.call(target, key) if (!hadKey) &#123; key = toRaw(key) hadKey = has.call(target, key) &#125; else if (__DEV__) &#123; checkIdentityKeys(target, has, key) &#125; const oldValue = get ? get.call(target, key) : undefined const result = target.delete(key) if (hadKey) &#123; // 如果删除的是之前存在的字段，触发一次 delete 依赖 trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue) &#125; return result&#125; clear拦截 clear 操作 12345678910111213141516171819/** * 拦截 clear 操作 * @param this proxy 对象 reactive 对象 */function clear(this: IterableCollections) &#123; const target = toRaw(this) const hadItems = target.size !== 0 const oldTarget = __DEV__ ? isMap(target) ? new Map(target) : new Set(target) : undefined const result = target.clear() if (hadItems) &#123; // 如果之前有元素，触发一次依赖事件 trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget) &#125; return result&#125; forEach拦截 forEach 操作 1234567891011121314151617181920212223/** * 拦截 forEach 操作 * @param isReadonly 是否只读 * @param isShallow 是否浅代理 */function createForEach(isReadonly: boolean, isShallow: boolean) &#123; return function forEach( this: IterableCollections, // proxy 对象 callback: Function, // 回调函数 thisArg?: unknown // 改变的 this 的值 ) &#123; const observed = this as any const target = observed[ReactiveFlags.RAW] const rawTarget = toRaw(target) // 原始的值 const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive // 不是只读，触发一次iterate依赖 !isReadonly &amp;&amp; track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY) return target.forEach((value: unknown, key: unknown) =&gt; &#123; // forEach callback 中接收到的值，是 reactive / readonly 类型 return callback.call(thisArg, wrap(value), wrap(key), observed) &#125;) &#125;&#125; keys 、values、entriescreateIterableMethod返回一个方法 拦截 iterate 操作，返回一个遍历器，for of 遍历就是基于遍历器实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 返回一个方法 拦截 iterate 操作 * @param method 方法名称 keys values entries * @param isReadonly 是否只读 * @param isShallow 是否浅代理 */function createIterableMethod( method: string | symbol, isReadonly: boolean, isShallow: boolean) &#123; return function( this: IterableCollections, // this 是 proxy 对象 ...args: unknown[] ): Iterable &amp; Iterator &#123; const target = (this as any)[ReactiveFlags.RAW] const rawTarget = toRaw(target) const targetIsMap = isMap(rawTarget) // 是否 map 遍历 iterate const isPair = method === &#x27;entries&#x27; || (method === Symbol.iterator &amp;&amp; targetIsMap) // 是否获取map的keys const isKeyOnly = method === &#x27;keys&#x27; &amp;&amp; targetIsMap const innerIterator = target[method](...args) const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive // 收集依赖 !isReadonly &amp;&amp; track( rawTarget, TrackOpTypes.ITERATE, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY ) // return a wrapped iterator which returns observed versions of the // values emitted from the real iterator // 返回的是一个next函数，next函数返回 value 和 done ，这是 iterable 接口规范 // value 的值还是一个 reactive / readonly / ... 的值 return &#123; // iterator protocol next() &#123; const &#123; value, done &#125; = innerIterator.next() return done ? &#123; value, done &#125; : &#123; value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value), done &#125; &#125;, // iterable protocol [Symbol.iterator]() &#123; return this &#125; &#125; &#125;&#125; shallowReactive 方法参数接收一个对象，返回对象的浅代理，通过 createReactiveObject 方法 12345678export function shallowReactive&lt;T extends object&gt;(target: T): T &#123; return createReactiveObject( target, false, shallowReactiveHandlers, shallowCollectionHandlers )&#125; shallowReactiveHandlers12345678export const shallowReactiveHandlers: ProxyHandler&lt;object&gt; = extend( &#123;&#125;, mutableHandlers, &#123; get: shallowGet, set: shallowSet &#125;) 用了新的 get 和 set 方法 12const shallowGet = /*#__PURE__*/ createGetter(false, true)const shallowSet = /*#__PURE__*/ createSetter(true) 用了上面提到的 createGetter 和 createSetter 方法 shallowCollectionHandlers123export const shallowCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123; get: createInstrumentationGetter(false, true)&#125; 用的还是上面提到的 createInstrumentationGetter 方法 readonly 方法参数接收一个对象，返回一个只读 readonly 对象，通过 createReactiveObject 方法 12345678910export function readonly&lt;T extends object&gt;( target: T): DeepReadonly&lt;UnwrapNestedRefs&lt;T&gt;&gt; &#123; return createReactiveObject( target, true, readonlyHandlers, readonlyCollectionHandlers )&#125; readonlyHandlers123456789101112131415161718192021export const readonlyHandlers: ProxyHandler&lt;object&gt; = &#123; get: readonlyGet, set(target, key) &#123; // 不做任何改变，直接返回 true if (__DEV__) &#123; console.warn( `Set operation on key &quot;$&#123;String(key)&#125;&quot; failed: target is readonly.`, target ) &#125; return true &#125;, deleteProperty(target, key) &#123; // 不做任何改变，直接返回 true if (__DEV__) &#123; console.warn( `Delete operation on key &quot;$&#123;String(key)&#125;&quot; failed: target is readonly.`, target ) &#125; return true &#125;&#125; get 方法 readonlyGet 1const readonlyGet = /*#__PURE__*/ createGetter(true) 使用的是上面提到的 createGetter 方法 readonlyCollectionHandlers123export const readonlyCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123; get: createInstrumentationGetter(true, false)&#125; 用的 createInstrumentationGetter 方法，创建的 handle 对象 shallowReadonly 方法参数接收一个对象，返回一个只读 readonly 的对象，这个只读，只针对对象的第一层，不做深层的代理， 通过 createReactiveObject 方法 12345678910export function shallowReadonly&lt;T extends object&gt;( target: T): Readonly&lt;&#123; [K in keyof T]: UnwrapNestedRefs&lt;T[K]&gt; &#125;&gt; &#123; return createReactiveObject( target, true, shallowReadonlyHandlers, readonlyCollectionHandlers )&#125; shallowReadonlyHandlers1234567export const shallowReadonlyHandlers: ProxyHandler&lt;object&gt; = extend( &#123;&#125;, readonlyHandlers, &#123; get: shallowReadonlyGet &#125;) get 方法 shallowReadonlyGet 1const shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true) readonlyCollectionHandlers123export const readonlyCollectionHandlers: ProxyHandler&lt;CollectionTypes&gt; = &#123; get: createInstrumentationGetter(true, false)&#125; 上面已经提到过 createReactiveObject 方法参数 参数 描述 target 需要代理的源数据（一般是对象，可以是Map/Set/WeakMap/WeakSet） isReadonly 是否创建只读对象 baseHandlers target 是 Object/Array 时，proxy 的 handle 对象 collectionHandlers target 是 Map/Set/WeakMap/WeakSet时，proxy 的 handle 对象 返回一个 proxy 对象，会对返回的 proxy 和 target 做一个缓存，如果对同一个对象多次调用该方法，获取到的是同一个对象 12345678910111213141516171819202122232425262728293031323334353637383940414243function createReactiveObject( target: Target, isReadonly: boolean, baseHandlers: ProxyHandler&lt;any&gt;, collectionHandlers: ProxyHandler&lt;any&gt;) &#123; // 如果不是对象类型，就直接返回 参数本身 if (!isObject(target)) &#123; if (__DEV__) &#123; console.warn(`value cannot be made reactive: $&#123;String(target)&#125;`) &#125; return target &#125; // 如果target是只读对象，并且要获取只读对象的时候，就直接返回 target if ( target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE]) ) &#123; return target &#125; // 如果 target 已经有了对象的代理对象，直接返回这个代理 const proxyMap = isReadonly ? readonlyMap : reactiveMap const existingProxy = proxyMap.get(target) if (existingProxy) &#123; return existingProxy &#125; /** * targetType 指定要跳过或者不可扩展，或者不是Object/Array/Map/WeakMap/Set/WeakSet TargetType.INVALID * Object/Array TargetType.COMMON * Map/Set/WeakMap/WeakSet TargetType.COLLECTION */ const targetType = getTargetType(target) if (targetType === TargetType.INVALID) &#123; return target &#125; const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) // 保存一下这个代理对象 proxyMap.set(target, proxy) return proxy&#125; isReactive 方法通过 ReactiveFlags.IS_REACTIVE / __v_isReactive 属性判断是不是 reactive 对象，这个对象的获取在 proxy 的 handle 中做了处理 123456export function isReactive(value: unknown): boolean &#123; if (isReadonly(value)) &#123; return isReactive((value as Target)[ReactiveFlags.RAW]) &#125; return !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_REACTIVE])&#125; 示例： 123456setup() &#123; const b = Vue.reactive(&#123;a: 123&#125;) console.log(Vue.isReactive(b)) // true console.log(Vue.isReactive(&#123;__v_isReactive: true&#125;)) // true console.log(Vue.isReactive(&#123;__v_isReactive: 1&#125;)) // true&#125; isReadonly 方法通过 ReactiveFlags.IS_READONLY / __v_isReadonly 判断是否是 readonly 类型 123export function isReadonly(value: unknown): boolean &#123; return !!(value &amp;&amp; (value as Target)[ReactiveFlags.IS_READONLY])&#125; 示例： 123456setup() &#123; const b = Vue.readonly(&#123;a: 123&#125;) console.log(Vue.isReadonly(b)) // true console.log(Vue.isReadonly(&#123;__v_isReadonly: true&#125;)) // true console.log(Vue.isReadonly(&#123;__v_isReadonly: 1&#125;)) // true&#125; isProxy 方法判断数据是不是 reactive 或者 readonly 类型的数据 123export function isProxy(value: unknown): boolean &#123; return isReactive(value) || isReadonly(value)&#125; 示例： 12345678setup() &#123; const a = Vue.reactive(&#123;a: 123&#125;) const b = Vue.readonly(&#123;a: 123&#125;) console.log(Vue.isProxy(a)) // true console.log(Vue.isProxy(b)) // true console.log(Vue.isProxy(&#123;__v_isReadonly: true&#125;)) // true console.log(Vue.isProxy(&#123;__v_isReactive: true&#125;)) // true&#125; toRaw 方法方法接收一个参数，如果参数是 reactive / readonly 对象会返回 reactive 对象的原始值，如果不是 reactive 对象，就返回接收的参数 ReactiveFlags.RAW 在 reactive 对象的 get 方法中做了处理 12345export function toRaw&lt;T&gt;(observed: T): T &#123; return ( (observed &amp;&amp; toRaw((observed as Target)[ReactiveFlags.RAW])) || observed )&#125; 示例： 12345678setup() &#123; const a = Vue.reactive(&#123;a: 123&#125;) const b = Vue.readonly(&#123;b: 123&#125;) console.log(Vue.toRaw(a)) // &#123;a: 123&#125; console.log(Vue.toRaw(b)) // &#123;b: 123&#125; console.log(Vue.toRaw(&#123;__v_isReadonly: true&#125;)) // &#123;__v_isReadonly: true&#125; console.log(Vue.toRaw(&#123;__v_isReactive: true&#125;)) // &#123;__v_isReactive: true&#125;&#125; markRaw 方法接收一个参数对象，标记这个对象是不需要代理的，通过 ReactiveFlags.SKIP / __v_skip 实现，会给对象添加一个 __v_skip 属性，值是 true 1234export function markRaw&lt;T extends object&gt;(value: T): T &#123; def(value, ReactiveFlags.SKIP, true) return value&#125; 示例： 1234567setup() &#123; const a = Vue.markRaw(&#123;a: 123&#125;) console.log(a) // &#123;a: 123, __v_skip: true&#125; console.log(Vue.reactive(&#123;a: 123&#125;)) // Proxy &#123;a: 123&#125; console.log(Vue.reactive(a)) // &#123;a: 123, __v_skip: true&#125; console.log(Vue.reactive(&#123;__v_skip: true&#125;)) // &#123;__v_skip: true&#125;&#125;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"reactive","slug":"reactive","permalink":"https://wukang0718.com/tags/reactive/"}]},{"title":"computed源码","slug":"computed源码","date":"2022-09-02T08:58:18.000Z","updated":"2022-09-02T08:59:04.069Z","comments":true,"path":"2022/09/02/computed源码/","link":"","permalink":"https://wukang0718.com/2022/09/02/computed%E6%BA%90%E7%A0%81/","excerpt":"","text":"源码位置： https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/computed.ts computed接收一个参数可以是一个 function 或者是一个对象，对象必须有 get 方法，可以设置 set 方法，返回一个有 value 属性的对象 1234567891011121314151617181920212223242526272829/** * 计算属性的方法 * @param getterOrOptions get 方法 或者 是一个对象，对象中包括 get 和 set 方法 */export function computed&lt;T&gt;( getterOrOptions: ComputedGetter&lt;T&gt; | WritableComputedOptions&lt;T&gt;) &#123; let getter: ComputedGetter&lt;T&gt; let setter: ComputedSetter&lt;T&gt; // 参数是一个函数的时候，就是 getter 函数 if (isFunction(getterOrOptions)) &#123; getter = getterOrOptions setter = __DEV__ ? () =&gt; &#123; console.warn(&#x27;Write operation failed: computed value is readonly&#x27;) &#125; : NOOP &#125; else &#123; getter = getterOrOptions.get setter = getterOrOptions.set &#125; // ComputedRefImpl 返回这个实例 return new ComputedRefImpl( getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set ) as any&#125; ComputedRefImpl 类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 一个 computed 实例 * getter 方法 * _setter 方法 * isReadonly 是否可以修改 */class ComputedRefImpl&lt;T&gt; &#123; private _value!: T private _dirty = true public readonly effect: ReactiveEffect&lt;T&gt; // 有一个 __v_isRef 属性 为 true ，在调用 isRef 的时候，返回 true public readonly __v_isRef = true; public readonly [ReactiveFlags.IS_READONLY]: boolean constructor( getter: ComputedGetter&lt;T&gt;, private readonly _setter: ComputedSetter&lt;T&gt;, isReadonly: boolean ) &#123; // 调用 effect 方法，收集 getter 方法中的依赖 this.effect = effect(getter, &#123; lazy: true, // 方法不会立即执行 scheduler: () =&gt; &#123; // 只有这个 值 被使用过，才会重新计算 if (!this._dirty) &#123; this._dirty = true // 等下一次或者值的时候，才会调用 trigger(toRaw(this), TriggerOpTypes.SET, &#x27;value&#x27;) &#125; &#125; &#125;) this[ReactiveFlags.IS_READONLY] = isReadonly &#125; get value() &#123; if (this._dirty) &#123; this._value = this.effect() // 这个就是 getter 函数执行的结果 this._dirty = false &#125; // 收集依赖 track(toRaw(this), TrackOpTypes.GET, &#x27;value&#x27;) return this._value &#125; set value(newValue: T) &#123; this._setter(newValue) &#125;&#125; 示例： 123456789101112131415setup() &#123; const a = Vue.ref(1) const b = Vue.computed(() =&gt; &#123; console.log(&quot;computed&quot;); return a.value * 2 &#125;) a.value = 2; a.value = 3; a.value = 4; console.log(b.value) // computed 8 a.value = 5; a.value = 6; console.log(b.value) // computed 12 console.log(Vue.isRef(b)) // true&#125;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"computed","slug":"computed","permalink":"https://wukang0718.com/tags/computed/"}]},{"title":"effect源码","slug":"effect源码","date":"2022-09-02T08:57:22.000Z","updated":"2022-09-02T08:58:39.897Z","comments":true,"path":"2022/09/02/effect源码/","link":"","permalink":"https://wukang0718.com/2022/09/02/effect%E6%BA%90%E7%A0%81/","excerpt":"","text":"源码位置： https://github.com/vuejs/vue-next/blob/master/packages/reactivity/src/effect.ts 这个文件的方法暴露在 “@vue/reactivity” effect执行需要收集依赖的函数，又有的依赖收集的调用，都要通过这个函数执行 1234567891011121314151617181920/** * 执行需要收集依赖的函数，又有的依赖收集的调用，都要通过这个函数执行 * @param fn Function 在这个函数里收集依赖 * @param options */export function effect&lt;T = any&gt;( fn: () =&gt; T, options: ReactiveEffectOptions = EMPTY_OBJ): ReactiveEffect&lt;T&gt; &#123; if (isEffect(fn)) &#123; fn = fn.raw // 获取到函数的原始值 &#125; // 获取到的是一个 加了 effect 标识的函数，并且在这个函数中处理了依赖收集需要的参数 const effect = createReactiveEffect(fn, options) if (!options.lazy) &#123; // 没有配置懒执行 effect() &#125; return effect&#125; createReactiveEffect执行一个需要收集依赖的函数，返回一个 effect 类型的函数 12345678910111213141516171819202122232425262728293031323334353637383940/** * 执行一个需要收集依赖的函数，返回一个 effect 类型的函数 * @param fn Function * @param options 配置参数 */function createReactiveEffect&lt;T = any&gt;( fn: () =&gt; T, options: ReactiveEffectOptions): ReactiveEffect&lt;T&gt; &#123; // 这个函数不会立即执行，是否执行，在 effect 函数中控制 // 用户在 options 中配置了 lazy：true 可以让这个函数 在 effect 中不执行 const effect = function reactiveEffect(): unknown &#123; // 调用了 stop 后会停止这个函数的依赖处理部分的继续执行 if (!effect.active) &#123; return options.scheduler ? undefined : fn() &#125; // 保证函数不会重复执行 if (!effectStack.includes(effect)) &#123; cleanup(effect) // 清除 函数的依赖相关 try &#123; enableTracking() // 启动依赖收集 effectStack.push(effect) // 把当前函数 推到 effect 栈中 activeEffect = effect // 这个就是依赖收集的时候，收集到的和依赖相关的函数 return fn() // fn 执行结束了，也就结束了依赖收集 &#125; finally &#123; effectStack.pop() // 函数执行完，出栈 resetTracking() // 恢复依赖收集，在 fn 中可能执行了 pauseTracking 方法，停止了依赖收集 activeEffect = effectStack[effectStack.length - 1] // 下一次需要被依赖收集的函数 &#125; &#125; &#125; as ReactiveEffect effect.id = uid++ effect.allowRecurse = !!options.allowRecurse effect._isEffect = true effect.active = true effect.raw = fn effect.deps = [] effect.options = options return effect&#125; pauseTracking暂停依赖收集 1234567/** * 暂停收集依赖 */export function pauseTracking() &#123; trackStack.push(shouldTrack) shouldTrack = false // shouldTrack 会停止依赖收集&#125; enableTracking启动依赖收集 1234567/** * 启动依赖收集 */export function enableTracking() &#123; trackStack.push(shouldTrack) shouldTrack = true&#125; resetTracking重置依赖收集，把依赖收集的状态恢复到上一次，默认是 true 1234567/** * 重置依赖收集 */export function resetTracking() &#123; const last = trackStack.pop() shouldTrack = last === undefined ? true : last&#125; track收集依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 收集依赖 * @param target 收集依赖的依赖源 * @param type 依赖的类型，可以是get、has、iterate * @param key 依赖的哪个属性 */export function track(target: object, type: TrackOpTypes, key: unknown) &#123; // shouldTrack 标识是否收集依赖，可以调用 pauseTracking 暂停收集依赖 // activeEffect 渲染时是 当前组件的渲染任务 // 在执行 effect 或者 watchEffect 时，调用了 ref.value(或者其他会获取依赖的方法)，就是当前 effect（或者其他方法）传递的函数 if (!shouldTrack || activeEffect === undefined) &#123; return &#125; // targetMap 是 WeakMap 类型，在 依赖的源对象被垃圾回收后，会自动删除这个key // depsMap 是对 target 收集的依赖 // depsMap 是一个 Map类型 let depsMap = targetMap.get(target) if (!depsMap) &#123; targetMap.set(target, (depsMap = new Map())) &#125; // dep 是 set 类型 let dep = depsMap.get(key) if (!dep) &#123; // 这里收集需要触发的依赖，使用set类型，保证没有重复的依赖 /** * targetMap(WeakMap): &#123; * target(Map): &#123; * key(Set): [] * &#125; * &#125; */ depsMap.set(key, (dep = new Set())) &#125; // 在这里把依赖收集起来 if (!dep.has(activeEffect)) &#123; dep.add(activeEffect) activeEffect.deps.push(dep) if (__DEV__ &amp;&amp; activeEffect.options.onTrack) &#123; // onTrack 只在开发的时候可以有效，可以用来追踪依赖收集 activeEffect.options.onTrack(&#123; effect: activeEffect, target, type, key &#125;) &#125; &#125;&#125; trigger触发依赖，effect 的 scheduler 配置也是在这里被执行的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/** * 触发依赖 * @param target 触发依赖的数据源 * @param type 触发依赖的类型可以是 set/add/delete/clear * @param key 触发依赖的 key，对应着收集依赖的key * @param newValue 新值 * @param oldValue 旧值 * @param oldTarget 旧的数据源 */export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;) &#123; // depsMap 获取到 target 对应的 Map 依赖源 const depsMap = targetMap.get(target) // 没有需要触发的依赖 if (!depsMap) &#123; // never been tracked return &#125; const effects = new Set&lt;ReactiveEffect&gt;() const add = (effectsToAdd: Set&lt;ReactiveEffect&gt; | undefined) =&gt; &#123; if (effectsToAdd) &#123; effectsToAdd.forEach(effect =&gt; &#123; // allowRecurse 设置为 true 会导致函数被多次触发 if (effect !== activeEffect || effect.allowRecurse) &#123; // 把依赖添加到 effects 中 effects.add(effect) &#125; &#125;) &#125; &#125; if (type === TriggerOpTypes.CLEAR) &#123; // collection being cleared // trigger all effects for target // 调用了 .clear 方法，触发 target 的所有依赖 depsMap.forEach(add) &#125; else if (key === &#x27;length&#x27; &amp;&amp; isArray(target)) &#123; // 改变了 数组的 length // 要触发 被删除的 元素的 依赖 和 length 的依赖 depsMap.forEach((dep, key) =&gt; &#123; if (key === &#x27;length&#x27; || key &gt;= (newValue as number)) &#123; add(dep) &#125; &#125;) &#125; else &#123; // schedule runs for SET | ADD | DELETE if (key !== void 0) &#123; // depsMap.get(key) 是一个 Set // 触发 target 上 相关这个 key 的依赖，最普通的情况 add(depsMap.get(key)) &#125; // also run for iteration key on ADD | DELETE | Map.SET switch (type) &#123; case TriggerOpTypes.ADD: // 添加事件触发 if (!isArray(target)) &#123; // 数组的遍历要触发 add(depsMap.get(ITERATE_KEY)) if (isMap(target)) &#123; // map 的编辑需要触发 add(depsMap.get(MAP_KEY_ITERATE_KEY)) &#125; &#125; else if (isIntegerKey(key)) &#123; // 数组添加一项 // new index added to array -&gt; length changes // 数组长度变化，需要触发 length 的相关依赖 add(depsMap.get(&#x27;length&#x27;)) &#125; break case TriggerOpTypes.DELETE: // 删除事件触发 if (!isArray(target)) &#123; // 数组遍历事件触发 add(depsMap.get(ITERATE_KEY)) if (isMap(target)) &#123; // map 遍历事件触发 add(depsMap.get(MAP_KEY_ITERATE_KEY)) &#125; &#125; break case TriggerOpTypes.SET: if (isMap(target)) &#123; // 触发 map 的遍历 add(depsMap.get(ITERATE_KEY)) &#125; break &#125; &#125; const run = (effect: ReactiveEffect) =&gt; &#123; // onTrigger 开发环境可以用 if (__DEV__ &amp;&amp; effect.options.onTrigger) &#123; effect.options.onTrigger(&#123; effect, target, key, type, newValue, oldValue, oldTarget &#125;) &#125; if (effect.options.scheduler) &#123; // 如果 effect 中设置了 scheduler，调用这个方法，自定义是否需要触发依赖 // effect 和 watchEffect 方法可以设置，其他方法（watch）??? TODO effect.options.scheduler(effect) &#125; else &#123; effect() &#125; &#125; // 调用所有依赖添加的函数 effects.forEach(run)&#125;","categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"effect","slug":"effect","permalink":"https://wukang0718.com/tags/effect/"}]},{"title":"createApp源码","slug":"createApp源码","date":"2022-09-02T08:52:20.000Z","updated":"2022-09-02T08:58:32.110Z","comments":true,"path":"2022/09/02/createApp源码/","link":"","permalink":"https://wukang0718.com/2022/09/02/createApp%E6%BA%90%E7%A0%81/","excerpt":"","text":"源码位置：https://github.com/vuejs/vue-next/blob/master/packages/runtime-dom/src/index.ts 都是源码，比较干。。。 v 3.0.4 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738/** * createApp 函数 */export const createApp = ((...args) =&gt; &#123; const app = ensureRenderer().createApp(...args) // 开发环境 校验 组件的 name 是不是内置的标签同名 if (__DEV__) &#123; injectNativeTagCheck(app) &#125; const &#123; mount &#125; = app /** * 重写了 mount 函数 * @param containerOrSelector */ app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; &#123; // container 是真实的 DOM 元素 const container = normalizeContainer(containerOrSelector) if (!container) return const component = app._component // 组件的options // 默认 组件的 template 是 挂载元素的内容 if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123; component.template = container.innerHTML &#125; // 清空 容器中的内容 container.innerHTML = &#x27;&#x27; const proxy = mount(container) if (container instanceof Element) &#123; // 删除元素上的 v-cloak 指令 container.removeAttribute(&#x27;v-cloak&#x27;) container.setAttribute(&#x27;data-v-app&#x27;, &#x27;&#x27;) &#125; return proxy &#125; return app&#125;) as CreateAppFunction&lt;Element&gt; 调用 ensureRenderer().createApp(...args) 方法，获取到了 app 的实例；然后重写了 app 的 mount 方法，在新的 mount 方法中，先对 container 做了一次处理（如果传的是css选择器，通过 document.querySelector 方法获取到的DOM元素 ），让 container 是一个真实的 DOM元素。 在组件不是一个函数，并且没有设置 render 函数和 tempalte 参数的时候，默认 container 中的 innerHTML 就是组件的 template。 调用 app 中返回的 mount 方法，完成 DOM 的挂载 ensureRenderer123456/** * 惰性 创建 renderer */function ensureRenderer() &#123; return renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions))&#125; 惰性创建 renderer 对象，这个对象的创建和运行的平台有关系，在 WEB 平台时，参数 rendererOptions 这个是 DOM 操作的 API createRenderer123456export function createRenderer&lt; HostNode = RendererNode, HostElement = RendererElement&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) &#123; return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)&#125; 这个方法直接返回了 baseCreateRenderer 方法，baseCreateRenderer 方法有几个重载的方法。 baseCreateRenderer 源码位置： https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/renderer.ts 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function baseCreateRenderer( options: RendererOptions, createHydrationFns?: typeof createHydrationFunctions): any &#123; // WEB 平台获取到的是操作 DOM 的方法 const &#123; insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent &#125; = options const patch = () =&gt; &#123;...&#125; const processText = () =&gt; &#123;...&#125; const processCommentNode = () =&gt; &#123;...&#125; const mountStaticNode = () =&gt; &#123;...&#125; const patchStaticNode = () =&gt; &#123;...&#125; const moveStaticNode = () =&gt; &#123;...&#125; const removeStaticNode = () =&gt; &#123;...&#125; const processElement = () =&gt; &#123;...&#125; const mountElement = () =&gt; &#123;...&#125; const setScopeId = () =&gt; &#123;...&#125; const mountChildren = () =&gt; &#123;...&#125; const patchElement = () =&gt; &#123;...&#125; const patchBlockChildren = () =&gt; &#123;...&#125; const patchProps = () =&gt; &#123;...&#125; const processFragment = () =&gt; &#123;...&#125; const processComponent = () =&gt; &#123;...&#125; const mountComponent = () =&gt; &#123;...&#125; const updateComponent = () =&gt; &#123;...&#125; const setupRenderEffect = () =&gt; &#123;...&#125; const updateComponentPreRender = () =&gt; &#123;...&#125; const patchChildren = () =&gt; &#123;...&#125; const patchUnkeyedChildren = () =&gt; &#123;...&#125; const patchKeyedChildren = () =&gt; &#123;...&#125; const move = () =&gt; &#123;...&#125; const unmount = () =&gt; &#123;...&#125; const remove = () =&gt; &#123;...&#125; const removeFragment = () =&gt; &#123;...&#125; const unmountComponent = () =&gt; &#123;...&#125; const unmountChildren = () =&gt; &#123;...&#125; const getNextHostNode = () =&gt; &#123;...&#125; const render = () =&gt; &#123;...&#125; return &#123; render, hydrate, // createApp 入口 createApp: createAppAPI(render, hydrate) &#125;&#125; 在 createApp 中调用了 ensureRenderer().createApp(...args) 方法获取 app 的实例，就是 baseCreateRenderer 返回的对象中的 createApp 函数，通过 createAppAPI 函数生成的一个函数 createAppAPI 源码位置：https://github.com/vuejs/vue-next/blob/master/packages/runtime-core/src/apiCreateApp.ts 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 返回 app 实例 * @param render * @param hydrate */export function createAppAPI&lt;HostElement&gt;( render: RootRenderFunction, hydrate?: RootHydrateFunction): CreateAppFunction&lt;HostElement&gt; &#123; /** * 接收两个参数 * rootComponent 根组件 * rootProps 传递给根组件的 props */ return function createApp(rootComponent, rootProps = null) &#123; const context = createAppContext() // 返回一个对象 // 安装的插件 const installedPlugins = new Set() // 是否挂载 let isMounted = false const app = (context.app = &#123; _uid: uid++, // 唯一id _component: rootComponent as ConcreteComponent, _props: rootProps, _container: null, _context: context, version, // vue 版本 get config() &#123; // config 是一个只读对象，设置 config 在开发环境会报警告 return context.config &#125;, use() &#123;...&#125;, mixin() &#123;...&#125;, component() &#123;...&#125;, directive() &#123;...&#125;, mount() &#123;...&#125;, unmount() &#123;...&#125;, provide() &#123;...&#125; &#125;) return app &#125;&#125; 在 runtime-dom 的 createApp 中，重写了 mount 方法，在其中调用了 app.mount 方法。 mount123456789101112131415161718192021222324/** * 组件挂载 * @param rootContainer * @param isHydrate */mount(rootContainer: HostElement, isHydrate?: boolean): any &#123; if (!isMounted) &#123; // 创建 vnode 节点 const vnode = createVNode( rootComponent as ConcreteComponent, rootProps ) // 节点的 vnode 挂载 context vnode.appContext = context // 忽略其他平台的执行，和开发环境的警告 // ... // 执行 render 函数 render(vnode, rootContainer) isMounted = true app._container = rootContainer // 返回 ??? return vnode.component!.proxy &#125;&#125; 在 mount 方法中，执行了 createVNode 方法创建了一个 组件的 vnode，然后执行了 render 方法。 createVNode创建 vnode 节点 123export const createVNode = (__DEV__ ? createVNodeWithArgsTransform : _createVNode) as typeof _createVNode 不考虑开发环境的情况，直接看 _createVNode 方法 _createVNode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 创建 vnode 的方法 * @param type * @param props * @param children * @param patchFlag * @param dynamicProps * @param isBlockNode */function _createVNode( type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT, props: (Data &amp; VNodeProps) | null = null, children: unknown = null, patchFlag: number = 0, dynamicProps: string[] | null = null, isBlockNode = false): VNode &#123; if (isVNode(type)) &#123; // 如果 type 已经是一个 vnode，返回 clone 的 vnode const cloned = cloneVNode(type, props, true /* mergeRef: true */) if (children) &#123; normalizeChildren(cloned, children) &#125; return cloned &#125; // 处理 class 组件，vue3 中已经取消了 class 组件 // ... // class &amp; style normalization. // 处理 props class 转成 字符串, style 转成 对象 // encode the vnode type information into a bitmap const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(type) ? ShapeFlags.SUSPENSE : isTeleport(type) ? ShapeFlags.TELEPORT : isObject(type) ? ShapeFlags.STATEFUL_COMPONENT : isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT : 0 // 新的 vnode 节点 const vnode: VNode = &#123; __v_isVNode: true, [ReactiveFlags.SKIP]: true, type, props, key: props &amp;&amp; normalizeKey(props), ref: props &amp;&amp; normalizeRef(props), scopeId: currentScopeId, children: null, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag, patchFlag, dynamicProps, dynamicChildren: null, appContext: null &#125; // validate key 校验 key 不是 NaN // ... // 处理子节点 normalizeChildren(vnode, children) if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123; const &#123; content, fallback &#125; = normalizeSuspenseChildren(vnode) vnode.ssContent = content vnode.ssFallback = fallback &#125; if ( shouldTrack &gt; 0 !isBlockNode &amp;&amp; currentBlock &amp;&amp; (patchFlag &gt; 0 || shapeFlag &amp; ShapeFlags.COMPONENT) &amp;&amp; patchFlag !== PatchFlags.HYDRATE_EVENTS ) &#123; currentBlock.push(vnode) &#125; return vnode&#125; 这个方法返回了一个新的 vnode，即使传入的参数已经是一个 vnode 节点，也会 clone 一份新的 vnode 节点，并返回。 然后看在 mount 中调用的另一个方法 render rendermount中调用的这个 render 方法是在调用 createAppAPI 方法 的时候，传入的参数。也就是 baseCreateRenderer 方法中定义的 render 方法 123456789101112131415const render: RootRenderFunction = (vnode, container) =&gt; &#123; // vnode === null 卸载组件 if (vnode == null) &#123; if (container._vnode) &#123; // 卸载组件需要执行 unmount(container._vnode, null, null, true) &#125; &#125; else &#123; // patch 更新和或者创建组件 patch(container._vnode || null, vnode, container) &#125; flushPostFlushCbs() // 保存组件的 vnode container._vnode = vnode&#125; render 方法中通过 patch 方法，将 vnode 转化成真实的 DOM，并挂载在页面上。 patch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const patch: PatchFn = ( n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, optimized = false) =&gt; &#123; // 新旧节点类型不同的时候，直接删除旧的节点 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123; anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null &#125; const &#123; type, ref, shapeFlag &#125; = n2 switch (type) &#123; case Text: // ... break case Comment: // ... break case Static: // ... break case Fragment: // ... break default: // 处理其他类型的节点 // ... if (shapeFlag &amp; ShapeFlags.COMPONENT) &#123; processComponent( // 处理component n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) &#125; &#125; // 处理 绑定的 ref if (ref != null &amp;&amp; parentComponent) &#123; setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2) &#125;&#125; patch 过程中，会根据 vnode 的 type 不同，调用不同的处理节点的方法，这里主要看处理 component 的方法 processComponent，因为这里会执行 setup 和收集依赖。 processComponent123456789101112131415161718192021222324252627const processComponent = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, optimized: boolean ) =&gt; &#123; if (n1 == null) &#123; // ... // 挂载 component mountComponent( n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) &#125; else &#123; // 更新组件 updateComponent(n1, n2, optimized) &#125; &#125; 可以看出创建组件使用了 mountComponent 方法，更新组件使用了 updateComponent 方法，先看 mountComponent，再看 updateComponent。 mountComponent123456789101112131415161718192021222324252627282930313233343536const mountComponent: MountComponentFn = ( initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) =&gt; &#123; // createComponentInstance 会对 instance 做处理, ctx 的不一致，就是在这个方法处理的 const instance: ComponentInternalInstance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent, parentSuspense )) // ... // 这里调用 setup 方法，setup 返回的值，会保存在 instance.setupState 中 setupComponent(instance) // ... if (__FEATURE_SUSPENSE__ &amp;&amp; instance.asyncDep) &#123; // 处理 setup 是 promise 的情况，在 promise 的状态 resolve 之后，才执行 setupRenderEffect 函数 parentSuspense &amp;&amp; parentSuspense.registerDep(instance, setupRenderEffect) // ... return &#125; setupRenderEffect( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized ) &#125; 这个方法里通过 createComponentInstance 生成了 instance 这个 instance 是通过 getCurrentInstance 获取到的 instance ，instance 的 ctx 属性，在 dev 环境和 prod 是两个东西，生产环境中不要使用 函数最后执行了 setupRenderEffect 方法，在这个方法的执行过程中，会收集 vnode 中使用到的依赖 createComponentInstance123456789101112131415161718192021export function createComponentInstance( vnode: VNode, parent: ComponentInternalInstance | null, suspense: SuspenseBoundary | null) &#123; // ... const instance: ComponentInternalInstance = &#123; // ... &#125; // 开发环境对 ctx 做的特殊处理 // 项目开发中不能使用这个 ctx，生产环境不支持 if (__DEV__) &#123; instance.ctx = createRenderContext(instance) &#125; else &#123; instance.ctx = &#123; _: instance &#125; &#125; instance.root = parent ? parent.root : instance instance.emit = emit.bind(null, instance) return instance&#125; setupRenderEffect12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const setupRenderEffect: SetupRenderEffectFn = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; instance.update = effect(function componentEffect() &#123; // 新建组件 if (!instance.isMounted) &#123; let vnodeHook: VNodeHook | null | undefined const &#123; el, props &#125; = initialVNode // 对子节点处理 这里会执行 组件的 render 函数 // render 函数对 ref / reactive 的值的获取，都会把当前函数作为依赖变更需要触发的函数收集 const subTree = (instance.subTree = renderComponentRoot(instance)) patch( // 这个patch执行会完成DOM的挂载 null, subTree, container, anchor, instance, parentSuspense, isSVG ) initialVNode.el = subTree.el instance.isMounted = true initialVNode = container = anchor = null as any &#125; else &#123; // 更新组件 let &#123; next, bu, u, parent, vnode &#125; = instance let originNext = next let vnodeHook: VNodeHook | null | undefined const nextTree = renderComponentRoot(instance) const prevTree = instance.subTree instance.subTree = nextTree patch( prevTree, nextTree, // parent may have changed if it&#x27;s in a teleport hostParentNode(prevTree.el!)!, // anchor may have changed if it&#x27;s in a fragment getNextHostNode(prevTree), instance, parentSuspense, isSVG ) next.el = nextTree.el &#125; &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)&#125; setupRenderEffect 函数执行会调用 effect 函数，只有在 effect 中执行的函数，才可以做依赖收集，通过 renderComponentRoot 方法创建组件的子节点，这个方法执行了组件的 render 方法，render方法中对 reactive 类型的值的获取和 ref / computed 类型的 .value 的获取，都会把这个 effect 函数作为变更的依赖做收集。 在执行 effect 的时候，传递了第二个参数 prodEffectOptions，这个参数中，有一个 scheduler 方法，这个是依赖更新之后会调用的调度器，这个调度器决定什么时候执行 DOM 更新，而不是每次依赖变化都对 DOM 做修改。 在这个方法也会执行 beforeMount 的 hooks 函数，之后执行的 renderComponentRoot 结束之后，再次执行一个 patch 方法，这个方法中，完成了组件创建到 DOM 的动作。并且对组件模板中绑定的 ref 做处理。通过 setRef 方法。 在之后执行了 mounted 的 hooks 函数。 组件的渲染就结束了！！！","categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"createApp","slug":"createApp","permalink":"https://wukang0718.com/tags/createApp/"}]},{"title":"项目升级到vue3之后build执行两遍打包","slug":"项目升级到vue3之后build执行两遍打包","date":"2022-04-25T03:16:31.000Z","updated":"2022-04-25T03:19:45.869Z","comments":true,"path":"2022/04/25/项目升级到vue3之后build执行两遍打包/","link":"","permalink":"https://wukang0718.com/2022/04/25/%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E5%88%B0vue3%E4%B9%8B%E5%90%8Ebuild%E6%89%A7%E8%A1%8C%E4%B8%A4%E9%81%8D%E6%89%93%E5%8C%85/","excerpt":"","text":"vue2 项目升级到vue3之后npm run build执行两遍打包 实际是在 @vue/cli-service升级到5.0版本之后出现的问题 先说解决方法两种办法 执行 build 的时候加一个 --no-module 1vue-cli-service build --no-module 修改 browserslist，一般在 package.json 中或者单独的 .browserslistrc 文件中，添加一个 not ie 11 package.json 123456&quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not dead&quot;, &quot;not ie 11&quot; ] .browserslistrc 1234&gt; 1%last 2 versionsnot deadnot ie 11 分析原因通过执行 npm run build 的时候打印的日志可以发现两次打包之前都输出了不一样的日志 1Building legacy bundle for production... 1Building module bundle for production... 正常只执行一次的打包只会输出一种日志 1Building for production... 然后我们根据日志输出的关键字在 @vue/cli-service 项目中查找一下，我们执行的是 build 命令，所以先看这个命令的文件 @vue/cli-service/lib/commands/build/index.js，搜索一下关键字 legacy bundle 会查找到第 116 行 12345678if (args.target === &#x27;app&#x27;) &#123; const bundleTag = args.needsDifferentialLoading ? args.moduleBuild ? `module bundle ` : `legacy bundle ` : `` logWithSpinner(`Building $&#123;bundleTag&#125;for $&#123;mode&#125;...`) &#125; 发现当 args.needsDifferentialLoading 为 true 的时候就会出现打包两次所出现的日志，所以基本可以肯定问题出在这个上，继续找一下它的复制，往上查找，在67行发现了赋值语句 1args.needsDifferentialLoading = needsDifferentialLoading 继续查找 needsDifferentialLoading 变量声明和赋值的地方，往上看就可以看到 123456789const &#123; allProjectTargetsSupportModule &#125; = require(&#x27;../../util/targets&#x27;)let needsDifferentialLoading = args.target === &#x27;app&#x27; &amp;&amp; args.moduleif (allProjectTargetsSupportModule) &#123; log( `All browser targets in the browserslist configuration have supported ES module.\\n` + `Therefore we don&#x27;t build two separate bundles for differential loading.\\n` ) needsDifferentialLoading = false&#125; needsDifferentialLoading 初始值如果 args.module 是 false 的话就是 false 在正常的项目开发中 arr.target 的值一定是 app，如果开发的是插件的话，那么一般在打包的时候会指定 --target lib 还有就是如果 allProjectTargetsSupportModule 这个值是true的话， needsDifferentialLoading 会被手动赋值成 false ，于是我们发现了两个可以让 needsDifferentialLoading 是 false 的方法 –no-module的原理先查找 args.module 的复制，会发现没有直接的赋值，args是整个回调函数的参数，而且在下面还给 args中没有的部分值，附上了默认参数，第23行 1234567891011121314151617181920212223api.registerCommand(&#x27;build&#x27;, &#123; description: &#x27;build for production&#x27;, usage: &#x27;vue-cli-service build [options] [entry|pattern]&#x27;, options: &#123; // ... &#x27;--no-module&#x27;: `build app without generating &lt;script type=&quot;module&quot;&gt; chunks for modern browsers`, // ... &#125; &#125;, async (args, rawArgs) =&gt; &#123; for (const key in defaults) &#123; if (args[key] == null) &#123; args[key] = defaults[key] &#125; &#125; // ...&#125;)// defaults 第一行const defaults = &#123; clean: true, target: &#x27;app&#x27;, module: true, formats: &#x27;commonjs,umd,umd-min&#x27;&#125; 可以看到 defaults 中给了 module 一个默认值true， 那怎么让 module 变成 false 呢，其实可以看到 options 中有一项 --no-module 的描述是: 构建应用程序，无需为现代浏览器生成&lt; script type=”module “ &gt;，到这里基本就能猜到了加个 --no-module 就可以把 module 赋值成 false 了，但猜到归猜到了，我们还是看一下具体的实现吧。 从 package.json 中确定程序执行的入口 bin/vue-cli-service.js 123&quot;bin&quot;: &#123; &quot;vue-cli-service&quot;: &quot;bin/vue-cli-service.js&quot;&#125;, 在 bin/vue-cli-service.js 中通过 minimist 解析了参数，并创建了 Service 的实例，并调用了 run 方法，并传入了解析后的参数 minimist 会把参数中以 --no- 开头的参数，解析为 false minimist/index.js 1234if (/^--no-.+/.test(arg)) &#123; var key = arg.match(/^--no-(.+)/)[1]; setArg(key, false, arg);&#125; bin/vue-cli-service.js 123456const Service = require(&#x27;../lib/Service&#x27;)const service = new Service(process.env.VUE_CLI_CONTEXT || process.cwd())const rawArgv = process.argv.slice(2)const args = require(&#x27;minimist&#x27;)(rawArgv, &#123;/*...*/&#125;)const command = args._[0]service.run(command, args, rawArgv) Service 在实例化的时候，添加了内置的 plugin 其中就包括了 ./command/build 命令 lib/Service.js 123456789101112131415161718192021222324252627module.exports = class Service &#123; constructor (context, &#123; plugins, pkg, inlineOptions, useBuiltIn &#125; = &#123;&#125;) &#123; // ... this.commands = &#123;&#125; this.plugins = this.resolvePlugins(plugins, useBuiltIn) &#125; resolvePlugins(inlinePlugins, useBuiltIn) &#123; const idToPlugin = (id, absolutePath) =&gt; (&#123; id: id.replace(/^.\\//, &#x27;built-in:&#x27;), apply: require(absolutePath || id) &#125;) let plugins const builtInPlugins = [ &#x27;./commands/build&#x27;, // ... ].map((id) =&gt; idToPlugin(id)) if (inlinePlugins) &#123; // ... &#125; else &#123; const projectPlugins = // ... plugins = builtInPlugins.concat(projectPlugins) &#125; const orderedPlugins = sortPlugins(plugins) return orderedPlugins &#125;&#125; 执行了 service.run 方法，run 方法中调用了 init 方法，在 init 方法中初始化好了插件之后，用传入的参数调用对应的回调函数 123456789101112131415161718async run (name, args = &#123;&#125;, rawArgv = []) &#123; // load env variables, load user config, apply plugins await this.init(mode) args._ = args._ || [] let command = this.commands[name] if (!command || args.help || args.h) &#123; command = this.commands.help &#125; const &#123; fn &#125; = command return fn(args, rawArgv)&#125;init() &#123; // apply plugins. this.plugins.forEach((&#123; id, apply &#125;) =&gt; &#123; if (this.pluginsToSkip.has(id)) return apply(new PluginAPI(id, this), this.projectOptions) &#125;)&#125; 为每一个插件创建了一个 PluginAPI 的实例，PluginAPI 提供了 registerCommand 方法，并把回调函数保存在了service.commands 中 12345678910111213class PluginAPI &#123; constructor (id, service) &#123; this.id = id this.service = service &#125; registerCommand (name, opts, fn) &#123; if (typeof opts === &#x27;function&#x27;) &#123; fn = opts opts = null &#125; this.service.commands[name] = &#123; fn, opts: opts || &#123;&#125; &#125; &#125;&#125; 至此 build 的回调函数就收到了解析后的参数 module: false not ie 11来看第二种解决方案的原理，只要从 ../../util/targets 中导入的allProjectTargetsSupportModule 值为 true，就可以了 1234const &#123; allProjectTargetsSupportModule &#125; = require(&#x27;../../util/targets&#x27;)if (allProjectTargetsSupportModule) &#123; needsDifferentialLoading = false&#125; lib/util/targets.js 1234567891011121314151617181920const projectTargets = getTargets()const allModuleTargets = getTargets( &#123; esmodules: true &#125;, &#123; ignoreBrowserslistConfig: true &#125;)const allProjectTargetsSupportModule = doAllTargetsSupportModule(projectTargets)function doAllTargetsSupportModule (targets) &#123; const browserList = Object.keys(targets) return browserList.every(browserName =&gt; &#123; if (!allModuleTargets[browserName]) &#123; return false &#125; return semver.gte( semver.coerce(targets[browserName]), semver.coerce(allModuleTargets[browserName]) ) &#125;)&#125; getTargets 是 babel 提供的方法，如果参数为空，返回 browserlists 查询的默认值，参考：https://babeljs.io/docs/en/babel-helper-compilation-targets#gettargets 传入 esmodules: true ，返回 https://github.com/babel/babel/blob/v7.13.15/packages/babel-compat-data/data/native-modules.json 这个json文件中查询的结果. 在 doAllTargetsSupportModule 方法中对 browserList 和 allModuleTargets进行了比较，如果 browserList 中有 allModuleTargets 不存在的属性，就返回 false 或者 browserList 中的版本号，比 allModuleTargets 小，也会返回 false 输出对比一下这两个对象 123456789101112131415161718192021222324 // browserList&#123; android: &#x27;98.0.0&#x27;, chrome: &#x27;97.0.0&#x27;, edge: &#x27;98.0.0&#x27;, firefox: &#x27;96.0.0&#x27;, ie: &#x27;11.0.0&#x27;, ios: &#x27;14.5.0&#x27;, opera: &#x27;82.0.0&#x27;, safari: &#x27;15.2.0&#x27;, samsung: &#x27;15.0.0&#x27;&#125;// allModuleTargets&#123; android: &#x27;61.0.0&#x27;, chrome: &#x27;61.0.0&#x27;, edge: &#x27;16.0.0&#x27;, firefox: &#x27;60.0.0&#x27;, ios: &#x27;10.3.0&#x27;, node: &#x27;13.2.0&#x27;, opera: &#x27;48.0.0&#x27;, safari: &#x27;10.1.0&#x27;, samsung: &#x27;8.2.0&#x27;&#125; 发现 browserList 比 allModuleTargets 中多了一个 ie: 11.0.0 ，那我们只要配置 browserlists 让他没有 ie 这一项就可以，ie最后的版本就是 11了，所以加一个 not IE 11 就可以了。 参考资料[1] https://babeljs.io/docs/en/babel-helper-compilation-targets#gettargets [2] https://github.com/browserslist/browserslist#query-composition","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3","slug":"vue/vue3","permalink":"https://wukang0718.com/categories/vue/vue3/"},{"name":"vue2升级vue3","slug":"vue/vue3/vue2升级vue3","permalink":"https://wukang0718.com/categories/vue/vue3/vue2%E5%8D%87%E7%BA%A7vue3/"}],"tags":[{"name":"vue2升级vue3","slug":"vue2升级vue3","permalink":"https://wukang0718.com/tags/vue2%E5%8D%87%E7%BA%A7vue3/"},{"name":"build","slug":"build","permalink":"https://wukang0718.com/tags/build/"}]},{"title":"第六篇-项目展示基本框架","slug":"第六篇-项目展示基本框架","date":"2021-09-17T03:37:13.000Z","updated":"2021-09-17T06:29:58.769Z","comments":true,"path":"2021/09/17/第六篇-项目展示基本框架/","link":"","permalink":"https://wukang0718.com/2021/09/17/%E7%AC%AC%E5%85%AD%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B1%95%E7%A4%BA%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/","excerpt":"","text":"在后台管理的项目中来说，一般会分 头部、侧边栏、和内容区域三个部分 在项目根目录下创建 layout 文件夹，完成这个三个部分的组件，并将这些组件组合在一起 新建 layout/index.vue 文件，搭建项目的基本框架，为了方便查看效果，把 src/App.vue 的 template 只保留 el-config-provider 和 router-view，其他删除，script 也做对应的删除，style 内设置 #app 的样式 1234567891011121314151617&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;#app &#123; width: 100vw; height: 100vh;&#125;&lt;/style&gt; 在 src/router/index.ts 中把 path: &quot;/&quot; 的路由的 component 改成 Layout src/router/index.ts 12345678import Layout from &quot;@/layout/index.vue&quot;;const routes: Array&lt;RouteRecordRaw&gt; = [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Layout, &#125;]; layout – 布局在 src/layout/index.vue 中，使用 element-plus的Container 布局容器 需要用到的组件有：el-container 、el-header 、el-aside、el-main，在 src/theme/index.ts 中引入这些组件。然后就可以在 src/layout/index.vue 中使用了。 src/theme/index.ts 12345678import &#123; // ... 省略其他导入 ElContainer&#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; // ... 省略其他代码 app.use(ElContainer);&#125;; 在 src/layout/index.vue 中，应该把头部、侧边栏和内容区域的宽高都划分好 src/layout/index.vue 12345678910111213141516171819&lt;template&gt; &lt;el-container class=&quot;layout&quot; style=&quot;background: red&quot;&gt; &lt;el-header style=&quot;background: green&quot;&gt;&lt;/el-header&gt; &lt;el-container&gt; &lt;el-aside style=&quot;background: blue&quot;&gt;&lt;/el-aside&gt; &lt;el-main style=&quot;background: yellow&quot;&gt;&lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.layout &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; 打开浏览器就可以看到划分好的区域了 接下来就把头部和侧边栏提取到单独的组件中，内容区域展示的子路由的内容所以要换成 router-view 在 src/layout 下新建 Header.vue 和 Aside.vue src/layout/Header.vue 123456789&lt;template&gt; &lt;el-header&gt;&lt;/el-header&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;LayoutHeader&quot;,&#125;;&lt;/script&gt; src/layout/Aside.vue 123456789&lt;template&gt; &lt;el-aside&gt;&lt;/el-aside&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;LayoutAside&quot;,&#125;;&lt;/script&gt; 在 src/layout/index.vue 中引入这两个组件 src/layout/index.vue 1234567891011121314151617181920212223&lt;template&gt; &lt;el-container class=&quot;layout&quot; direction=&quot;vertical&quot;&gt; &lt;layout-header style=&quot;background: green&quot;&gt;&lt;/layout-header&gt; &lt;el-container&gt; &lt;layout-aside style=&quot;background: blue&quot;&gt;&lt;/layout-aside&gt; &lt;el-main&gt; &lt;router-view /&gt; &lt;/el-main&gt; &lt;/el-container&gt; &lt;/el-container&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import LayoutAside from &quot;./Aside.vue&quot;;import LayoutHeader from &quot;./Header.vue&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.layout &#123; width: 100%; height: 100%;&#125;&lt;/style&gt; Aside – 侧边栏在侧边栏中需要提供模块菜单，这里需要用到 el-menu 组件，在 src/theme/index.ts 中引入 src/theme/index.ts 12345678import &#123; // ... ElMenu,&#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; // ... app.use(ElMenu);&#125;; src/layout/aside.vue 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;template&gt; &lt;el-aside&gt; &lt;el-menu :default-active=&quot;defaultActive&quot; @open=&quot;handleOpen&quot; @close=&quot;handleClose&quot; &gt; &lt;template v-for=&quot;(item, index) in menus&quot; :key=&quot;index&quot;&gt; &lt;el-sub-menu :index=&quot;`$&#123;index&#125;`&quot; v-if=&quot;item.children&quot;&gt; &lt;template #title&gt; &lt;i v-if=&quot;item.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item v-for=&quot;(elItem, elIndex) in item.children&quot; :key=&quot;elIndex&quot; :index=&quot;`$&#123;index&#125;-$&#123;elIndex&#125;`&quot; &gt; &lt;i v-if=&quot;elItem.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; elItem.name &#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item v-else&gt; &lt;i v-if=&quot;item.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; item.name &#125;&#125; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-menu&gt; &lt;/el-aside&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;export default &#123; name: &quot;LayoutAside&quot;,&#125;;&lt;/script&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; computed &#125; from &quot;vue&quot;;const menus = [ &#123; name: &quot;导航一&quot;, icon: &quot;el-icon-location&quot;, children: [ &#123; name: &quot;导航五&quot;, icon: &quot;el-icon-document&quot;, &#125;, &#123; name: &quot;导航六&quot;, icon: &quot;el-icon-settings&quot;, &#125;, ], &#125;, &#123; name: &quot;导航二&quot;, icon: &quot;el-icon-menu&quot;, children: [ &#123; name: &quot;导航三&quot;, icon: &quot;el-icon-document&quot;, &#125;, &#123; name: &quot;导航四&quot;, icon: &quot;el-icon-settings&quot;, &#125;, ], &#125;,];const hasChildren = (item: Record&lt;string, any&gt;) =&gt; !!item.children;const getDefaultActive = (list: Record&lt;string, any&gt;[], result = &quot;0&quot;) =&gt; &#123; const [item] = list; if (hasChildren(item)) &#123; result += &quot;-0&quot;; getDefaultActive(item.children, result); &#125; return result;&#125;;const defaultActive = computed(() =&gt; getDefaultActive(menus));&lt;/script&gt; 然后需要在 views 下创建菜单对应的文件夹，在 router 下也要创建对应的文件，每个模块都需要做这样重复的工作，这样的工作，应该让程序自动来做，写一个脚本来完成这样的工作。 create-module脚本在项目根目录下创建一个 scripts 文件夹存放自定义的脚本 在 scripts 下创建 create-module 文件夹，在文件夹中创建 create-module.js，在这个文件中处理模块，需要知道有哪些模块，所以还需要创建一个 module.json 文件 在 module.json 文件中，会出现下列字段 字段名 数据类型 备注 name string 路由的 path 和 name，子路由的 name 是 父路由子父路由拼接起来的 title string 左侧菜单展示的名称，页面 title children array 子路由，子菜单 show boolean 是否展示在左侧菜单中 redirect string 重定向的路由 示例 12345678910111213141516171819[ &#123; &quot;name&quot;: &quot;project&quot;, &quot;title&quot;: &quot;项目列表&quot;, &quot;redirect&quot;: &quot;/project/index&quot;, &quot;children&quot;: [ &#123; &quot;name&quot;: &quot;index&quot;, &quot;title&quot;: &quot;项目列表&quot;, &quot;show&quot;: false &#125;, &#123; &quot;name&quot;: &quot;lookTests&quot;, &quot;title&quot;: &quot;查看关联项目集&quot;, &quot;show&quot;: false &#125; ] &#125;] 需要在脚本中使用 eslint 所以需要安装 eslint 版本 7.0 以上的 123npm install eslint --save-dev# oryarn add eslint --dev 生成views下目录和文件 需要一个方法创建不存在的文件夹 12345678910111213141516171819202122232425262728293031323334const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const &#123; ESLint &#125; = require(&quot;eslint&quot;);const modules = require(&quot;./module.json&quot;);const viewsPath = path.join(__dirname, &quot;../../src/views/&quot;);const routerPath = path.join(__dirname, &quot;../../src/router&quot;);const routesPath = path.join(routerPath, &quot;/routes&quot;);/** * 工厂函数，创建以恶搞创建文件夹的方法 * @param &#123;string&#125; basePath 创建文件夹的基础路径 * @returns &#123; function &#125; 返回一个创建文件夹的具体方法 */const getCreateFolder = (basePath) =&gt; &#123; return async (folderName) =&gt; &#123; const folderPath = path.join(basePath, folderName); try &#123; const res = await fs.promises.stat(folderPath); if (!res.isDirectory()) &#123; // 不是文件夹的时候，创建文件夹 fs.promises.mkdir(folderPath); &#125; &#125; catch (err) &#123; // 找不到文件或文件夹或报错 fs.promises.mkdir(folderPath, &#123; recursive: true &#125;); &#125; &#125;;&#125;;/** * 创建 views 下的文件夹 */const createViewFolder = getCreateFolder(viewsPath); 创建vue模版 scripts/create-module/template/vue 123456789101112&lt;template&gt; &lt;div&gt;#&#123;name&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;#&#123;name&#125;&quot;,&#125;;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt; 需要一个方法创建不存在的文件 123456789101112131415161718192021222324252627282930313233343536/** * 工厂函数返回实际创建文件的方法 * @param &#123;string&#125; basePath 创建文件的基本路径 * @param &#123;string&#125; ext 文件后缀名 * @returns &#123;function&#125; 返回实际创建文件的方法 */const getCreateFile = (basePath, ext) =&gt; &#123; const templatePath = path.join(__dirname, &quot;/template/&quot;, ext.slice(1)); return async (fileName) =&gt; &#123; const filePath = path.join(basePath, `$&#123;fileName&#125;$&#123;ext&#125;`); const name = fileName.replace(/\\/\\w/gi, (res) =&gt; res.slice(1).toUpperCase() ); const write = async () =&gt; &#123; const templateStr = await fs.promises.readFile(templatePath, &#123; encoding: &quot;utf8&quot;, &#125;); await fs.promises.writeFile( filePath, templateStr.replace(/#&#123;name&#125;/g, name) ); &#125;; try &#123; const res = await fs.promises.stat(filePath); if (!res.isFile()) &#123; // 不是文件，可以写入内容 write(); &#125; &#125; catch (err) &#123; // 找不到文件或文件夹或报错 write(); &#125; &#125;;&#125;;const createViewFile = getCreateFile(viewsPath, &quot;.vue&quot;); 递归配置的模块创建views下的目录和文件 123456789101112131415161718192021222324/** * 创建 views 下的文件夹和文件夹 * @param &#123;&#123; * name: &quot;product&quot;, * title: &quot;项目&quot;, * children: [] * &#125;&#125; views 创建的模块 * @param &#123;string&#125; basePath 基于src/views/的路径 */const createViews = (views, basePath = &quot;/&quot;) =&gt; &#123; // 要创建的文件/文件夹的路径 const isFolder = !!views.children; if (isFolder) &#123; createViewFolder(basePath + views.name); &#125; else &#123; createViewFile(basePath + views.name); &#125; if (views.children) &#123; for (let i = 0; i &lt; views.children.length; i++) &#123; const element = views.children[i]; createViews(element, basePath + views.name + &quot;/&quot;); &#125; &#125;&#125;; 生成router/routes 下的文件 创建 routes 文件夹 1234/** * 创建 router/routes 下的文件夹 */const createRouteFolder = getCreateFolder(routesPath); 创建 routes 下文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * 拼接字符串，从第二个参数开始，首字母大写 * @param &#123;string&#125; str * @param &#123;...string&#125; arg * @returns string */const joinStr = (str, ...arg) =&gt; &#123; return (str ?? &quot;&quot;) + arg.map((item) =&gt; item[0].toUpperCase() + item.slice(1));&#125;;/** * 获取单个route的配置 * @param &#123;&#123; * name: &quot;product&quot;, * title: &quot;项目&quot;, * children: [] * &#125;&#125; routes 创建的模块 * @param isParent &#123;boolean&#125; 是否是顶级的路由 * @param parentName &#123;string&#125; 父路由的 name/path */const getRouteTmp = (route, isParent, parentName) =&gt; &#123; const path = isParent ? &quot;/&quot; + route.name : route.name; const name = isParent ? route.name : joinStr(parentName, route.name); const componentPath = isParent ? route.name : `$&#123;parentName&#125;/$&#123;route.name&#125;`; const isRedirect = route.redirect; const component = `component: () =&gt; import(/* webpackName: &quot;$&#123;name&#125;&quot; */&quot;@/views/$&#123;componentPath&#125;.vue&quot;),`; const redirect = `redirect: &quot;$&#123;isRedirect&#125;&quot;,component: () =&gt; import(/* webpackName: &quot;Layout&quot; */&quot;@/layout/index.vue&quot;),`; return `&#123; path: &quot;$&#123;path&#125;&quot;, name: &quot;$&#123;name&#125;&quot;, $&#123;isRedirect ? redirect : component&#125; meta: &#123; title: &quot;$&#123;route.title&#125;&quot; &#125;, $&#123; route.children?.length ? `children: [ $&#123;route.children ?.map((item) =&gt; getRouteTmp(item, false, route.name)) .join(&quot;,&quot;)&#125; ] ` : &quot;&quot; &#125; &#125; `;&#125;;/** * 创建 routes 下的文件 * @param &#123;&#123; * name: &quot;product&quot;, * title: &quot;项目&quot;, * children: [] * &#125;&#125; routes 创建的模块 */const createRouteFile = async (routes) =&gt; &#123; const filePath = path.join(routesPath, routes.name + &quot;.ts&quot;); const str = `export default $&#123;getRouteTmp(routes, true)&#125;;`; const write = async () =&gt; &#123; // 先用 eslint 修改一下代码格式 const results = await eslint.lintText(str); await fs.promises.writeFile(filePath, results[0].output); &#125;; try &#123; const res = await fs.promises.stat(filePath); if (!res.isFile()) &#123; // 不是文件，可以写入内容 write(); &#125; &#125; catch (err) &#123; // 找不到文件或文件夹或报错 write(); &#125;&#125;; 创建routes/index.ts 文件 12345678910111213141516171819202122232425/** * 创建 routes 下的index.ts 导出所有的路由 */const createRouteIndexFile = async () =&gt; &#123; let files = await fs.promises.readdir(routesPath); files = files .filter((file) =&gt; &#123; return file !== &quot;index.ts&quot; &amp;&amp; file.endsWith(&quot;.ts&quot;); &#125;) .map((file) =&gt; file.slice(0, -3)); let str = files .map((file) =&gt; `import $&#123;file&#125;Routes from &quot;./$&#123;file&#125;&quot;;`) .join(&quot;&quot;); str += ` export default [ $&#123;files.map((file) =&gt; file + &quot;Routes&quot;).join(&quot;,&quot;)&#125; ] `; // 先用 eslint 修改一下代码格式 const results = await eslint.lintText(str); await fs.promises.writeFile( path.join(routesPath, &quot;./index.ts&quot;), results[0].output );&#125;; 生成侧边栏的菜单123456789101112131415161718192021222324const menuPath = path.join(__dirname, &quot;../../src/layout&quot;);const getMenu = (menu, parentMenu = &quot;/&quot;) =&gt; &#123; const children = menu.children?.filter((item) =&gt; item.show !== false) || []; const route = parentMenu + menu.name; return &#123; name: menu.title, route: menu.redirect || parentMenu + menu.name, icon: menu.icon, children: children.length ? children.map((item) =&gt; getMenu(item, `$&#123;route&#125;/`)) : null, &#125;;&#125;;/** * 创建左侧侧边栏 */const createMenuFile = async () =&gt; &#123; const filePath = path.join(menuPath, &quot;./menu.json&quot;); const menus = modules .filter((menu) =&gt; menu.show !== false) .map((menu) =&gt; getMenu(menu)); await fs.promises.writeFile(filePath, JSON.stringify(menus, null, 4));&#125;; 创建一个入口函数1234567891011const run = async () =&gt; &#123; await createRouteFolder(&quot;/&quot;); for (const item of modules) &#123; createViews(item); await createRoutes(item); &#125; await createRouteIndexFile(); createMenuFile();&#125;;run(); 在 packgae.json 中添加一个 script 命令 1&quot;create:module&quot;: &quot;node ./scripts/create-module/create-module.js&quot; 执行命令 123yarn create:module# ornpm run create:module 在 src/router/index.ts 中引入创建的路由 123456789101112131415import Routes from &quot;./routes&quot;;const routes: Array&lt;RouteRecordRaw&gt; = [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Layout, &#125;, &#123; path: &quot;/about&quot;, name: &quot;About&quot;, component: () =&gt; import(/* webpackChunkName: &quot;about&quot; */ &quot;../views/About.vue&quot;), &#125;, ...Routes,]; 在 src/layout/Aside.vue 中引入创建的菜单 12345678910111213141516&lt;script lang=&quot;ts&quot; setup&gt;import &#123; computed &#125; from &quot;vue&quot;;import menus from &quot;./menu.json&quot;;const hasChildren = (item: Record&lt;string, any&gt;) =&gt; !!item.children;const getDefaultActive = (list: Record&lt;string, any&gt;[], result = &quot;0&quot;) =&gt; &#123; const [item] = list; if (hasChildren(item)) &#123; result += &quot;-0&quot;; getDefaultActive(item.children, result); &#125; return result;&#125;;const defaultActive = computed(() =&gt; getDefaultActive(menus));&lt;/script&gt; 在 tsconfig.json 中添加 resolveJsonModule 12345&#123; &quot;compilerOptions&quot;: &#123; &quot;resolveJsonModule&quot;: true &#125;&#125; 现在就可以看到页面的菜单了，但是点击菜单没有路由跳转 添加菜单跳转Aside.vue 文件中， el-menu 组件需要添加 router prop，el-menu-item 需要 route prop 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;el-aside&gt; &lt;el-menu :default-active=&quot;defaultActive&quot; router &gt; &lt;template v-for=&quot;(item, index) in menus&quot; :key=&quot;index&quot;&gt; &lt;el-sub-menu :index=&quot;`$&#123;index&#125;`&quot; v-if=&quot;item.children&quot;&gt; &lt;template #title&gt; &lt;i v-if=&quot;item.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;el-menu-item v-for=&quot;(elItem, elIndex) in item.children&quot; :key=&quot;elIndex&quot; :index=&quot;`$&#123;index&#125;-$&#123;elIndex&#125;`&quot; :route=&quot;elItem.route&quot; &gt; &lt;i v-if=&quot;elItem.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; elItem.name &#125;&#125; &lt;/el-menu-item&gt; &lt;/el-sub-menu&gt; &lt;el-menu-item v-else :index=&quot;`$&#123;index&#125;`&quot; :route=&quot;item.route&quot;&gt; &lt;i v-if=&quot;item.icon&quot; :class=&quot;item.icon&quot;&gt;&lt;/i&gt; &#123;&#123; item.name &#125;&#125; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-menu&gt; &lt;/el-aside&gt;&lt;/template&gt; 在配置一下路由 / 重定向到 /project/index src/router/index.ts 123456789const routes: Array&lt;RouteRecordRaw&gt; = [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Layout, redirect: &quot;/project/index&quot;, &#125;, // ...]; 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"第五篇-Vue3项目中集成axios","slug":"第五篇-Vue3项目中集成axios","date":"2021-09-10T01:32:53.000Z","updated":"2021-09-17T03:38:59.946Z","comments":true,"path":"2021/09/10/第五篇-Vue3项目中集成axios/","link":"","permalink":"https://wukang0718.com/2021/09/10/%E7%AC%AC%E4%BA%94%E7%AF%87-Vue3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90axios/","excerpt":"","text":"什么是 axios？Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。开箱即用的工具 这也是 Vue 官方推荐使用的发送 ajax 请求的工具 axios有哪些特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装 axios123npm install axios --save# oryarn add axios --save 在 src/App.vue 中使用一下 axios，添加以下代码 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;div&gt; &lt;h1&gt;请求的内容&lt;/h1&gt; &lt;div&gt;&#123;&#123; result &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;!-- 忽略其他代码 --&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;// 忽略其他代码import axios from &quot;axios&quot;;const result = ref(&quot;&quot;);axios.get(location.href).then((&#123; data &#125;) =&gt; &#123; result.value = data;&#125;);&lt;/script&gt; 在浏览器中就可以查看到我们网站的代码了 在日常项目的开发中，通常会有多个后端的服务，而每个服务会有自己的 url 地址、token之类的，通常是使用单独的 axios 的实例处理对应的服务，这就需要我们封装多个 axios 的实例 封装 axios在 src 目录下新建一个 axios 文件夹，在其中新建一个 index.ts 文件，这个文件就是用来导出封装好的 axios 使用 axios.create() 方法就可以创建一个 axios 的实例 axios 可以设置全局默认的配置，这些配置会被每个实例共享，实例可以覆盖这些配置 设置全局的参数 设置全局的接口超时时间 timeout，这个时间是对所有实例通用的 src/axios/index.ts 12import axios from &quot;axios&quot;;axios.defaults.timeout = 60 * 1000; // 设置超时时间是1分钟 创建 axios的实例假设我们的项目中会用到两个服务(a, b)的接口 接口地址/环境 development 开发环境 t 测试环境 production 生产环境 服务a http://a.dev.server.com http://a.test.server.com http://a.prod.server.com 服务b http://b.dev.server.com http://b.test.server.com http://b.prod.server.com 同一个服务根据不同的运行环境需要使用不同的接口地址，这种情况最好是把接口地址写在环境文件中 .env.development 中添加 12VUE_APP_A_BASE_URL=http://a.dev.server.comVUE_APP_B_BASE_URL=http://b.dev.server.com .env.t 中添加 12VUE_APP_A_BASE_URL=http://a.test.server.comVUE_APP_B_BASE_URL=http://b.test.server.com .env.production 中添加 12VUE_APP_A_BASE_URL=http://a.prod.server.comVUE_APP_B_BASE_URL=http://b.prod.server.com 在 src/axios/index.ts 文件中就可以通过 process.env.VUE_APP_A_BASE_URL 和 process.env.VUE_APP_B_BASE_URL 取到对应的服务地址 src/axios/index.ts 添加 1234567export const aService = axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL,&#125;);export const bService = axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL,&#125;); 创建并导出的两个 axios 的服务分别用来处理对应的两个后端服务的接口 设置请求拦截器请求拦截器可以处理哪些问题 在请求发送之前需要处理的事情，都可以在请求拦截器中处理 例如每个请求都要在请求头中添加 token 在请求发送之前遇到的错误都可以在请求拦截器中被处理 语法axios 设置请求拦截器的语法，要为实例添加拦截器只要把 axios 替换成对应的实例就可以了 1axios.interceptors.request.use(onFulfilled, onRejected); onFulfilled 函数，接收一个 config 的参数，可以对 config 进行修改，最后返回这个 config onRejected 函数，处理在请求发送之前的错误 请求拦截器的执行顺序是先添加的后执行 封装在 src/axios 下新建文件夹 interceptors 再 interceptors 新建一个 request 文件夹，这个文件夹中保存所有请求拦截器 请求错误处理的拦截器 把错误拦截器作为第一个拦截器，可以拦截到所有请求发出之前的错误，在这个也可以给服务器上报错误日志 同一个拦截器中的 onRejected 函数处理不到 onFulfilled 中的异常，所以最后一个请求拦截器的 onRejected 函数是不会被执行的 在 src/axios/interceptors/request 文件夹下新建 error.ts 文件，这个文件中做对请求开始之前的错误处理 src/axios/interceptors/request/error.ts 1234export default function handleRequestError(error: any): Promise&lt;any&gt; &#123; // 可以给服务器上报错误 return Promise.reject(error);&#125; eslint 提示 Unexpected any. Specify a different type. 在项目根目录下的 .eslintrc.js 文件中 rules 中添加一行 &quot;@typescript-eslint/no-explicit-any&quot;: &quot;off&quot;, eslint 提示 Argument ‘error’ should be typed with a non-any type. 在项目根目录下的 .eslintrc.js 文件中 rules 中添加一行 &quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;, 在 src/axios/interceptors/request 文件夹下新建 index.ts 文件，这个文件提供两个添加请求拦截器的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;import handleRequestError from &quot;./error&quot;;/** * 给axios的实例添加拦截器 * @param axiosService axios 的实例 * @param requestInterceptorArray 需要添加在实例上的拦截器 二维数组[[拦截器的onFulfilled, 拦截器的onRejected],[...]] * @returns 返回传入的axios的实例 */export function useBaseRequestInterceptor( axiosService: AxiosInstance, requestInterceptorArray: [ (config: AxiosRequestConfig) =&gt; AxiosRequestConfig, ((error: any) =&gt; any) | undefined ][]): AxiosInstance &#123; requestInterceptorArray.forEach((interceptor) =&gt; axiosService.interceptors.request.use(...interceptor) ); return axiosService;&#125;/** * 给axios的实例添加拦截器 * 在所有拦截器之前会添加一个错误拦截器 * @param axiosService axios 的实例 * @param requestInterceptorArray 需要添加在实例上的拦截器 一维数组，只处理onFulfilled函数 * @returns 返回传入的axios的实例 */export default function useRequestInterceptor( axiosService: AxiosInstance, requestInterceptorArray: Array&lt; (config: AxiosRequestConfig) =&gt; AxiosRequestConfig &gt; = []) &#123; const interceptors: [ (config: AxiosRequestConfig) =&gt; AxiosRequestConfig, undefined ][] = requestInterceptorArray.map((interceptor) =&gt; [interceptor, undefined]); return useBaseRequestInterceptor(axiosService, [ [(config: AxiosRequestConfig) =&gt; config, handleRequestError], ...interceptors, ]);&#125; 给 aService 和 bService 添加拦截器 src/axios/index.ts 12345678910111213import useRequestInterceptor from &quot;./interceptors/request&quot;;export const aService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;));export const bService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;)); 在 headers 中添加 token 的请求拦截器 在 src/axios/interceptors/request 文件夹下新建 token.ts 文件 1234567891011121314151617181920212223import &#123; AxiosRequestConfig &#125; from &quot;axios&quot;;/** * 处理 a 服务的token * @param config 请求的axios参数 * @returns 处理后的请求的axios参数 */export function handleAServiceRequestToken(config: AxiosRequestConfig) &#123; const token = &quot;a-service-token&quot;; // 这里要根据项目获取真实的token，从vuex或者本地存储中获取 config.headers[&quot;token&quot;] = token; return config;&#125;/** * 处理 b 服务的token * @param config 请求的axios参数 * @returns 处理后的请求的axios参数 */export function handleBServiceRequestToken(config: AxiosRequestConfig) &#123; const token = &quot;b-service-token&quot;; // 这里要根据项目获取真实的token，从vuex或者本地存储中获取 config.headers[&quot;token&quot;] = token; return config;&#125; 给 aService 和 bService 添加 token 拦截器 123456789101112131415161718import &#123; handleAServiceRequestToken, handleBServiceRequestToken,&#125; from &quot;./interceptors/request/token&quot;;export const aService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleBServiceRequestToken]); 还有其他需要在请求拦截器做的，都可以按照这种方式添加 设置响应拦截器响应拦截器可以处理哪些问题响应拦截器会在请求成功或失败之后调用 请求的错误 在这里判断服务器返回的数据是否有效，无效数据可以当作异常处理 如果接口返回的是文件可以在这里完成文件的下载 等等。。。 语法axios 设置响应拦截器的语法，要为实例添加拦截器只要把 axios 替换成对应的实例就可以了 1axios.interceptors.response.use(onFulfilled, onRejected); onFulfilled 函数，接收一个 AxiosResponse 的返回结果，可以对处理返回的接口进行修改，最后返回一个结果 onRejected 函数，处理请求异常的错误 响应拦截器的执行顺序是先添加的先执行 建议在拦截器中返回 result ，方便后续插拔拦截器的处理，可以考虑在错误拦截器之前的最后一个拦截器中返回 result.data 封装在 src/axios/interceptors 下新建一个 response 文件夹，这个文件夹中保存所有响应拦截器 同一个拦截器中的 onRejected 函数处理不到 onFulfilled 中的异常，所以第一个响应拦截器的 onRejected 函数是不会被执行的 响应错误处理的拦截器 在 src/axios/interceptors/response 文件夹下新建 error.ts 文件，这个文件中做对请求响应之后的错误拦截 把错误拦截器作为最后一个拦截器，可以拦截到所有响应拦截器中的错误 src/axios/interceptors/response/error.ts 123456789101112import &#123; ElMessage &#125; from &quot;element-plus&quot;;/** * 处理 axios 实例的响应错误 * @param error 响应错误消息 * @returns rejected 状态的promise */export default function handleResponseError(error: any): Promise&lt;any&gt; &#123; // 给服务器上传错误日志 ElMessage.error(error); return Promise.reject(error);&#125; 在 src/axios/interceptors/response 文件夹下新建 index.ts 文件，这个文件提供两个添加响应拦截器的方法 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; AxiosInstance, AxiosResponse &#125; from &quot;axios&quot;;import handleResponseError from &quot;./error&quot;;/** * 给axios的实例添加拦截器 * @param axiosService axios 的实例 * @param responseInterceptorArray 需要添加在实例上的拦截器 二维数组[[拦截器的onFulfilled, 拦截器的onRejected],[...]] * @returns 返回传入的axios的实例 */export function useBaseResponseInterceptor( axiosService: AxiosInstance, responseInterceptorArray: [ (result: AxiosResponse) =&gt; any, ((error: any) =&gt; any) | undefined ][]): AxiosInstance &#123; responseInterceptorArray.forEach((interceptor) =&gt; axiosService.interceptors.response.use(...interceptor) ); return axiosService;&#125;/** * 给axios的实例添加拦截器 * 在所有拦截器之前会添加一个错误拦截器 * @param axiosService axios 的实例 * @param responseInterceptorArray 需要添加在实例上的拦截器 一维数组，只处理onFulfilled函数 * @returns 返回传入的axios的实例 */export default function useResponseInterceptor( axiosService: AxiosInstance, responseInterceptorArray: Array&lt;(result: AxiosResponse) =&gt; any&gt; = []) &#123; const interceptors: [(result: AxiosResponse) =&gt; any, undefined][] = responseInterceptorArray.map((interceptor) =&gt; [interceptor, undefined]); return useBaseResponseInterceptor(axiosService, [ ...interceptors, [(res: AxiosResponse) =&gt; res, handleResponseError], ]);&#125; 给 aService 和 bService 添加响应拦截器 src/axios/index.ts 123456789101112131415161718192021import useResponseInterceptor from &quot;./interceptors/response&quot;;export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [] ), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [] ), [handleBServiceRequestToken]); 处理后端返回的数据，假设后端返回的 json 中有 code 字段，且只有 200 表示成功，其他的全部按照异常处理，如果异常的话会有 message 字段返回异常信息，在 src/axios/interceptors/response 下新建 filterResponse.ts 文件 src/axios/interceptors/response/filterResponse.ts 12345678910111213141516171819import &#123; AxiosResponse &#125; from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;/** * 对服务端返回的数据处理 * code !== 200 的都是有异常的 * @param response axios 响应消息 * @returns */export default function handleResponseFilter( response: AxiosResponse): AxiosResponse | Promise&lt;AxiosResponse&gt; &#123; const &#123; data &#125; = response; if (data.code !== 200) &#123; ElMessage.error(data.message); return Promise.reject(response); &#125; return response;&#125; src/axios/index.ts 123456789101112131415161718192021import handleResponseFilter from &quot;./interceptors/response/filterResponse&quot;;export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleResponseFilter] ), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleResponseFilter] ), [handleBServiceRequestToken]); 其他响应拦截器也可以使用这种方式添加 接口请求中展示loading 根据具体项目看要不要添加这个拦截器，这里用来做演示 在请求发出后 500ms 内如果收到了响应就不展示 loading，如果超过 500ms 就展示 loading，在接口响应之后关闭 loading。 在 src/axios 下创建一个 utils 文件夹，在其中新建一个loading.ts 文件，用来显示和关闭 loading src/axios/utils/loading.ts 123456789101112131415161718192021222324252627import &#123; ElLoading, ILoadingInstance &#125; from &quot;element-plus&quot;;let loadingCount = 0;let loading: ILoadingInstance | null = null;/** * 500ms 之后展示loading */export function showLoading(): NodeJS.Timeout &#123; loadingCount++; return setTimeout(() =&gt; &#123; if (!loading &amp;&amp; loadingCount) &#123; loading = ElLoading.service(); &#125; &#125;, 500);&#125;/** * 如果没有loading中的接口，就关闭loading */export function hideLoading() &#123; loadingCount--; if (loadingCount === 0 &amp;&amp; loading) &#123; loading.close(); loading = null; &#125;&#125; 在 src/axios/interceptors/request 和 src/axios/interceptors/response 文件夹下新建 loading.ts 文件，在 src/axios/utils 下新建 constants.ts 文件，用来存放常量 src/axios/utils/constants.ts 1export const HEADER_NO_LOADING = &quot;NO-LOADING&quot;; // 请求头中添加请求不展示loading的字段 src/axios/interceptors/request/loading.ts 12345678910111213141516171819import &#123; AxiosRequestConfig &#125; from &quot;axios&quot;;import &#123; showLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;../../utils/constants&quot;;/** * 处理 请求时展示 loading 的拦截器 * @param config * @returns */export default function handleRequestLoading( config: AxiosRequestConfig): AxiosRequestConfig &#123; const &#123; headers &#125; = config; // 如果 headers 中有 &quot;NO-LOADING&quot;: true 就不展示loading if (!headers[HEADER_NO_LOADING]) &#123; showLoading(); &#125; return config;&#125; src/axios/interceptors/response/loading.ts 123456789101112131415161718192021import &#123; AxiosResponse &#125; from &quot;axios&quot;;import &#123; hideLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;../../utils/constants&quot;;/** * 处理响应成功之后关闭loading的拦截器 * @param result * @returns */export default function handleResponseLoading( result: AxiosResponse): AxiosResponse &#123; const &#123; config: &#123; headers &#125;, &#125; = result; // 如果 headers 中有 &quot;NO-LOADING&quot;: true 就不处理loading if (!headers[HEADER_NO_LOADING]) &#123; hideLoading(); &#125; return result;&#125; 如果带有loading的请求出现了异常，要在 error 拦截器中关闭 loading src/axios/interceptors/response/error.ts 1234567891011121314151617181920import &#123; AxiosError &#125; from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; hideLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;@/axios/utils/constants&quot;;/** * 处理 axios 实例的响应错误 * @param error 响应错误消息 * @returns rejected 状态的promise */export default function handleResponseError( error: AxiosError): Promise&lt;AxiosError&gt; &#123; if (!error.config.headers[HEADER_NO_LOADING]) &#123; hideLoading(); &#125; // 给服务器上传错误日志 ElMessage.error(error.message); return Promise.reject(error);&#125; src/axios/index.ts 12345678910111213141516171819202122232425262728import handleRequestLoading from &quot;./interceptors/request/loading&quot;;import handleResponseLoading from &quot;./interceptors/response/loading&quot;;/** * 给a服务器发送请求的axios实例 */export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleAServiceRequestToken, handleRequestLoading]);/** * 给b服务器发送请求的axios实例 */export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleBServiceRequestToken, handleRequestLoading]); loading的拦截器就加完了，其他的项目中需要的拦截器也可以按照这种方式加入 配置反向代理如果项目开发中，后端的接口提供了跨域请求的支持，那这一步就可以不做了。 但是通常在项目开发中，后端的接口不会提供跨域请求的支持，这个时候就需要我们对请求做一个反向代理，webpack 通过 devServer.proxy 内置了这样的服务。 在根目录的 vue.config.js 文件中添加配置即可 例：给 a、b 服务配置代理 / 代理到 http://localhost:8082 （本地的服务启动的是多少就代理到多少） 首先把 a、b 两个服务的 axios 实例创建时的 baseURL 改成唯一的前缀 src/axios.index.ts 12345678910111213141516171819202122232425/** * 给a服务器发送请求的axios实例 */export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: &quot;/aServer&quot;, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleAServiceRequestToken, handleRequestLoading]);/** * 给b服务器发送请求的axios实例 */export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: &quot;/bServer&quot;, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleBServiceRequestToken, handleRequestLoading]); 然后在 vue.config.js 中配置对应的代理 vue.config.js 123456789101112131415161718192021222324module.exports = &#123; // ... 其他配置 devServer: &#123; // ... proxy: &#123; &quot;/aServer&quot;: &#123; target: process.env.VUE_APP_A_BASE_URL, changeOrigin: true, secure: false, pathRewrite: &#123; &quot;/aServer&quot;: &quot;&quot;, &#125;, &#125;, &quot;/bServer&quot;: &#123; target: process.env.VUE_APP_B_BASE_URL, changeOrigin: true, secure: false, pathRewrite: &#123; &quot;/bServer&quot;: &quot;&quot;, &#125;, &#125;, &#125;, &#125;,&#125; 这样在启动开发环境的时候，就对我们的请求做了反向代理，避免了跨域问题的产生 在项目上线的时候，一般会用一个静态资源服务器做前端入口，比如 nginx，那就可以在 nginx 上做反向代理 上线时候的反向代理用 nginx 做反向代理，一般会在项目根目录有一个 deployment 的文件夹，会存放一项目上线用到的配置文件，比如 nginx 的配置文件 在项目根目录下新建 deployment 文件夹，并在其中新建 test 和 prod 两个文件夹，在建立一个 nginx.conf.tmp 文件，这个文件作为我们生成 nginx.conf 的模版文件，需要根据自己项目的部署情况修改参数。 deployment/nginx.conf.tmp 12345678910111213141516171819server &#123; listen 80; root /usr/share/nginx/html/dist; # 上线服务器存放的位置 # 默认请求 location / &#123; try_files $uri $uri/ /index.html; # 解决history路由刷新404的问题 &#125; location ~ .*\\.(js|css)$ &#123; expires 30d; # 静态资源设置强缓存 &#125; # proxy_pass placeholder # 禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125;&#125; 在新建一个 genNginxConf.js 这个文件可以根据第一个参数创建对应环境的 default.conf 文件，这是部署项目用到的 nginx 的配置文件 deployment/genNginxConf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* eslint-disable @typescript-eslint/no-var-requires */const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const dotenv = require(&quot;dotenv&quot;);const dotenvExpand = require(&quot;dotenv-expand&quot;);const configFile = path.join(__dirname, &quot;../vue.config.js&quot;);const nginxFileName = &quot;default.conf&quot;;const configBaseFile = path.join(__dirname, &quot;./nginx.conf.tmp&quot;);const mode = process.argv[2];let filePath;let envPath;if (mode === &quot;t&quot; || mode === &quot;test&quot;) &#123; filePath = path.join(__dirname, &quot;test&quot;, nginxFileName); envPath = path.join(__dirname, &quot;../.env.t&quot;);&#125; else if (mode === &quot;prod&quot;) &#123; filePath = path.join(__dirname, &quot;prod&quot;, nginxFileName); envPath = path.join(__dirname, &quot;../.env.production&quot;);&#125; else &#123; console.log(`没有对应的模式：$&#123;mode&#125;`); process.exit(1);&#125;// 加载环境变量const env = dotenv.config(&#123; path: envPath &#125;);dotenvExpand(env);let proxyPass = ` # 配置反向代理`;if (fs.statSync(configFile).isFile()) &#123; const webpackConfig = require(configFile); const proxy = webpackConfig?.devServer?.proxy; if (proxy) &#123; for (const [k, &#123; target, pathRewrite &#125;] of Object.entries(proxy)) &#123; let metaPath = k; if (pathRewrite) &#123; Object.keys(pathRewrite).forEach((p) =&gt; &#123; metaPath = metaPath.replace(p, pathRewrite[p]); &#125;); &#125; proxyPass += ` location $&#123;k&#125; &#123; proxy_pass $&#123;target&#125;$&#123;metaPath&#125;; &#125; `; &#125; &#125; else &#123; console.log(&quot;没有配置 devServer.proxy，不需要设置代理&quot;); &#125;&#125; else &#123; console.log(&quot;没有 vue.config.js 文件，不需要设置代理&quot;);&#125;const tmpStr = fs.readFileSync(configBaseFile, &#123; encoding: &quot;utf8&quot; &#125;);fs.writeFileSync( filePath, tmpStr.replace(&quot;# proxy_pass placeholder&quot;, proxyPass));console.log(&quot;nginx 配置文件生成&quot;); 命令行执行 1node ./deployment/genNginxConf.js t 就可以看到 deployment/test/default.conf 文件被创建出来 把刚才的命令添加到 package.json 中的 scripts 中，方便之后的执行 12&quot;gennginx:t&quot;: &quot;node ./deployment/genNginxConf.js t&quot;,&quot;gennginx:prod&quot;: &quot;node ./deployment/genNginxConf.js prod&quot; 执行一下下面的命令，在 deployment/prod 下也会生层 default.conf 文件 123npm run gennginx:prod# oryarn gennginx:prod 修改一下 build 和 build:t 命令，在执行这个命令的时候，可以同时生成新的 nginx 配置文件 12&quot;build&quot;: &quot;vue-cli-service build &amp;&amp; npm run gennginx:prod&quot;,&quot;build:t&quot;: &quot;vue-cli-service build --mode t &amp;&amp; npm run gennginx:t&quot;, 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：页面基本框架","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"第四篇-添加工具规范 git commit message","slug":"第四篇-添加工具规范-git-commit-message","date":"2021-09-08T10:05:13.000Z","updated":"2021-09-10T01:35:04.948Z","comments":true,"path":"2021/09/08/第四篇-添加工具规范-git-commit-message/","link":"","permalink":"https://wukang0718.com/2021/09/08/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E8%A7%84%E8%8C%83-git-commit-message/","excerpt":"","text":"Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。 一般来说，commit message 应该清晰明了，说明本次提交的目的，是新增了一个功能或者修复了一个bug 之类的，但是随着项目组人员增多，仅靠口头的约束有时候还是会出错的，所以我们需要通过工具来帮助规范团队的 commit message。 规范的 commit message每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 typetype用于说明 commit 的类别，可以使用以下标识 1234567891011feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）perf：优化相关，比如提升性能、体验test：增加测试build：构建ci：更改ci configurationchore：构建过程或辅助工具的变动revert：撤销commit/回滚版本 如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况默认不加入，可以修改，建议不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。有以下限制 123以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。使用 git commit 会弹出多行编辑器 有两个注意点。 使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于两种情况。 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 123fix #1# 关闭多个fix #1, #2 validate-commit-msgvalidate-commit-msg 是什么?一个可以校验 commit message 的二进制文件 安装 validate-commit-msg123npm install validate-commit-msg --save-dev#oryarn add validate-commit-msg --dev validate-commit-msg 的配置可以通过项目根目录下的 .vcmrc 文件，或者在 package.json 中修改 .vcmrc 文件内容是一个正确的 json 格式 validate-commit-msg 提供了默认配置，一般项目开发不需要修改这个 123456789101112131415&#123; &quot;types&quot;: [&quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot;], &quot;scope&quot;: &#123; &quot;required&quot;: false, &quot;allowed&quot;: [&quot;*&quot;], &quot;validate&quot;: false, &quot;multiple&quot;: false &#125;, &quot;warnOnFail&quot;: false, &quot;maxSubjectLength&quot;: 100, &quot;subjectPattern&quot;: &quot;.+&quot;, &quot;subjectPatternErrorMsg&quot;: &quot;subject does not match subject pattern!&quot;, &quot;helpMessage&quot;: &quot;&quot;, &quot;autoFix&quot;: false&#125; 在 package.json 中修改配置 1234567&#123; &quot;config&quot;: &#123; &quot;validate-commit-msg&quot;: &#123; /* 这里写配置的参数 */ &#125; &#125;&#125; .vcmrc 文件的优先级更高，如果 .vcmrc 文件不存在，才会从 package.json 中读取 huskyhusky是什么？husky 是一个 Git Hook 工具。husky 其实就是一个为 git 客户端增加 hook 的工具。将其安装到所在仓库的过程中它会自动在 .git/ 目录下增加相应的钩子实现在pre-commit阶段就执行一系列流程保证每一个commit 的正确性。 安装 husky不同的包管理工具使用不一样的安装方法：官方文档 123npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2 执行之后会在项目根目录生成 .husky 目录，目录下会有一个 pre-commit 文件，把文件中的 npm test 修改为 npm run lint，如果你的项目中没有使用 eslint，可以把这个文件直接改名成 commit-msg，把文件中的 npm test 修改为 npx validate-commit-msg。 将 pre-commit 文件复制两份命名为 commit-msg 和 pre-push commit-msg 文件中的 npm run lint 修改为 npx validate-commit-msg pre-push 文件中的 npm run lint 修改为 npm run test:unit，如果你的项目没有使用单元测试可以不需要这个文件 pre-commit 会在输入提交信息之前调用，校验 eslint commit-msg 输入了提交信息，如果校验出错，放弃提交 pre-push git push 执行的时候 更新了远程引用但尚未推送到远程时被调用 测试一下 validate-commit-msg 和 husky 是否生效 回到项目根目录下执行 12git add .git commit -m &quot;随便提交点&quot; 出现以下信息代表 commit-msg 钩子中执行的 validate-commit-msg 生效了 123AINVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; !随便提交点husky - commit-msg hook exited with code 1 (error) 做一次正确的提交，commit msg 应该必须包含 type : 和 subject，scope 是可选的 12git commit -m &quot;chore: 添加husky和validate-commit-msg校验commit msg&quot;git push CommitizenCommitizen 是什么?Commitizen 是一个撰写合格 Commit message 的工具。 安装 Commitizen123npm install commitizen --save-dev#oryarn add commitizen --dev 初始化项目中使用 cz-conventional-changelog 适配器 1234# npm 包管理工具执行npx commitizen init cz-conventional-changelog --save-dev --save-exact# yarn 包管理工具执行npx commitizen init cz-conventional-changelog --yarn --dev --exact package.json 文件中会自动添加 commitizen 配置 12345&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot; &#125;&#125; 以后，凡是用到git commit命令，一律改为使用 cz。这时，就会出现选项，用来生成符合格式的 Commit message。 测试一下 12git add .npx cz 使用 git log 可以查看刚才的 commit message 还可以在 package.json 中添加更加方便的执行命令，在 package.json 的 scripts 中添加 12&quot;cz&quot;: &quot;cz&quot;,&quot;commit&quot;: &quot;git add . &amp;&amp; cz&quot; 之后在提交代码，就可以在项目根目录下执行 123npm run commit# oryarn commit 生成 changelog如果项目中所有的 commit 都是按照上述格式提交的，那么 change log，就可以用脚本自动生成。 生成的文档包括以下三个部分。 123New featuresBug fixesBreaking changes 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具 安装 conventional-changelog123npm install conventional-changelog-cli --save-dev# oryarn add conventional-changelog-cli --dev 命令行执行以下命令就会在项目根目录下生成 CHANGELOG.md 1npx conventional-changelog -p angular -i CHANGELOG.md -s 之后在发布新的版本的时候都可以使用这个命令，往 CHANGELOG.md 文件中，添加新版本的log 可以把这个命令添加到 package.json 中的 scripts 下，方便之后的使用 1&quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot; 之后就可以使用以下命令往 CHANGELOG.md 文件中，添加新版本的log 123npm run changelog# or yarn changelog 相关资料阮一峰 Commit message 和 Change log 编写指南 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：集成axios","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"第三篇-vue3 项目中配置模式和环境变量","slug":"第三篇-vue3-项目中配置模式和环境变量","date":"2021-09-08T03:15:47.000Z","updated":"2021-09-08T10:07:19.855Z","comments":true,"path":"2021/09/08/第三篇-vue3-项目中配置模式和环境变量/","link":"","permalink":"https://wukang0718.com/2021/09/08/%E7%AC%AC%E4%B8%89%E7%AF%87-vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"Vue内置的模式Vue CLI 内置了三种模式 developement 模式，使用 vue-cli-service serve 命令的时候，启动的开发环境就是这个模式，这个模式下运行的 webpack 会启动热更新，不会对资源进行 hash 也不会打出 vendor bundles，目的是为了在开发的时候能够快速重新构建。 test 模式，使用 vue-cli-service test:unit 命令的时候，启动的单元测试的环境就是这个模式，这个模式下的 webpack 不会处理图片以及一些对单元测试非必需的其他资源。 production 模式，vue-cli-service build 命令的时候，运用的就是这个模式，这个模式的 webpack 会运行 mode=production 的配置 自定义运行模式在执行 vue-cli-service 的命令的时候，可以通过 --mode 指定想要运行的模式，这将会覆盖默认的模式 例如在公司开发中，都会有一个测试环境，那么这个测试环境会有一些和开发/生产环境都不一样的东西，比如说我们后端服务的url，那么我们就可以给这个测试环境的打包指定一个模式，这样在打包的时候，会从指定模式的环境文件中加载环境变量，在 package.json 中添加一个 script 命令 &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;， 注意：尽量不要和默认的模式冲突 package.json 123456789101112&#123; ... &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;, &quot;test:e2e&quot;: &quot;vue-cli-service test:e2e&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125; ...&#125; 执行 npm run build:t 的时候会运行 t 模式，会从 .env / .env.local / .env.t / .env.t.local 这些文件中加载环境变量，稍后来创建环境文件 Vue内置的环境变量Vue CLI 内置了两个环境变量 环境变量/模式 development test production NODE_ENV development test production BASE_URL（就是vue.config.js中的publicPath ，默认是 /） / / / 自定义环境变量 当运行 vue-cli-service 命令时，所有的环境变量都从对应的环境文件中载入，这就给我们提供了自定义环境变量的方式 什么是环境文件在项目根目录下可以创建四种形式的环境文件 1234.env # 在所有的环境中被载入.env.local # 在所有的环境中被载入，但会被 git 忽略.env.[mode] # 只在指定的模式中被载入.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 环境文件只包含环境变量的“键=值”对： 1VUE_APP_BASE_URL=&quot;http://dev.server.com&quot; // 后端服务的url 环境文件的优先级 Vue CLI 启动时已经存在的环境变量拥有最高优先级，不会被 .env 文件覆盖，但是可以被 .env.[mode] 文件覆盖 为一个特定模式准备的环境文件 (例如 .env.t) 将会比一般的环境文件 (例如 .env) 拥有更高的优先级。 环境文件是通过运行 vue-cli-service 命令载入的，因此环境文件发生变化，你需要重启服务。 动态计算环境变量在 vue.config.js 文件中计算环境变量。它们仍然需要以 VUE_APP_ 前缀开头。 例如计算每次编译的版本和时间 1234/* eslint-disable @typescript-eslint/no-var-requires */const pkg = require(&quot;./package.json&quot;);process.env.VUE_APP_VERSION = pkg.version;process.env.VUE_APP_DATE_TIME = new Date().toLocaleString(); 环境变量的运用只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到代码中 例如上面提到的 VUE_APP_BASE_URL 就是已 VUE_APP 开头的 建议不要在任何文件修改 BASE_URL 的值，在执行 vue-cli-service build 命令的模式环境文件里都建议把 NODE_ENV 改成 production 先来配置一下环境变量看一下环境变量的用法 在根目录新建以下文件 .env.development 指定开发环境使用的环境变量 .env.production 指定生产环境使用的环境变量 .env.t 指定测试环境使用的环境变量 就简单配置一个用来区分运行环境的环境变量 VUE_APP_ENV ，这个变量可以任意取，只要求已 VUE_APP 开头，并且应该在所有的环境文件都包含这个环境变量 .env.development 1VUE_APP_ENV=dev .env.production 1VUE_APP_ENV=prod .env.t 1VUE_APP_ENV=t 在项目中使用环境变量通过 process.env.[环境变量] 的方式获取到运行模式的环境文件配置的环境变量的值 在 src/App.vue 中使用一下 123456789101112&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 忽略其他代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&#123;&#123; env &#125;&#125;&lt;/div&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; Ref, ref &#125; from &quot;@vue/reactivity&quot;;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;const env: Ref = ref(process.env.VUE_APP_ENV); // 启动项目这个值是dev&lt;/script&gt; 运行其他模式看一下结果，命令行执行 123yarn serve --mode t#ornpm run serve --mode t 运行 production 模式 123yarn serve --mode production#ornpm run serve --mode production 环境变量不只是在 src 下的文件可以使用，在根目录下的 babel.config.js / vue.config.js 等文件中也可以使用. 在 public/index.html 中使用环境变量所有解析出来的环境变量都可以在 public/index.html 中以 **HTML 插值**中介绍的方式使用。 因为 index 文件被用作模板，所以你可以使用 lodash template 语法插入内容： &lt;%= VALUE %&gt; 用来做不转义插值； &lt;%- VALUE %&gt; 用来做 HTML 转义插值； &lt;% expression %&gt; 用来描述 JavaScript 流程控制。 例如在 index.html 使用一个 meta 标签标记我们项目的模式、版本和打包的时间 123&lt;meta content=&quot;&lt;%= VUE_APP_ENV %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_VERSION %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_DATE_TIME %&gt;&quot;&gt; 执行打包命令看 dist 目录输出的html 123yarn build --mode development#or npm run build --mode development 运行 t 模式的打包 123yarn build:t#or npm run build:t 运行 production 模式的打包，build 的默认模式就是 production 123yarn build#or npm run build 实际开发中还需要的运行环境经过刚才的打包发现，在指定 --mode t 的时候，打包后的文件没有被压缩 这是因为没有指定 t 模式的 NODE_ENV=production ，所以使用的是 development 的 webpack 配置 所以要在环境文件中指定 NODE_ENV 的值 .env.development 1NODE_ENV=development .env.t 1NODE_ENV=production .env.production 1NODE_ENV=production 再次执行 yarn build:t 或 npm run build:t，dist 目录下的文件就已经是压缩过的了 还有其他实际开发中需要配置的环境变量，比如后端接口的地址，具体看自己项目吧 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：添加工具规范 git commit message","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"第二篇-Vue3 项目中集成 element-plus","slug":"第二篇-Vue3-项目中集成-element-plus","date":"2021-09-07T11:06:07.000Z","updated":"2021-09-13T05:30:32.526Z","comments":true,"path":"2021/09/07/第二篇-Vue3-项目中集成-element-plus/","link":"","permalink":"https://wukang0718.com/2021/09/07/%E7%AC%AC%E4%BA%8C%E7%AF%87-Vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90-element-plus/","excerpt":"","text":"基于上次使用 cli 搭建的 vue3 的项目来添加 element-plus cli搭建vue3项目 安装element-plus在项目所在目录打开命令行工具，执行以下命令安装 123npm install element-plus --save#or yarn add element-plus 我这里安装的最新版本是 1.1.0-beta.9 升级sass、sass-loader为什么要升级 sass、 sass-loader? 使用脚手架安装的 sass 的版本是 1.26.5 ， sass-loader 的版本是 8.0.2，而 element-plus@1.1.0-beta.9 版本的源码中使用的 sass 的版本是 1.39.0, sass-loader 的版本是 10.1.1 那我们就需要安装一下这两个版本，命令行执行以下命令 123npm install sass@1.39.0 sass-loader@10.1.1 --save-dev#or yarn add sass@1.39.0 sass-loader@10.1.1 --dev 使用按需引入为什么要使用按需引入? element-plus 的组件比较多，而我们的项目开发中并不一定会用到所有的组件，如果我们直接引入所有的组件，那么项目打包之后的文件体积较大，会导致浏览器的加载时间长，从而导致一些白屏时间长等的问题。 使用按需引入之后，在项目打包的时候，只会把我们引入的组件进行打包，其他我们没有引入使用的组件，不会打包我们的项目中，减少我们项目的体积，加快浏览器的加载效率。 配置按需引入 首先需要下载一个 babel 的插件 babel-plugin-import，命令行执行 123npm install babel-plugin-import --save-dev#oryarn add babel-plugin-import --dev 找到项目根目录下的 babel.config.js 文件 添加 babel.config.js 配置，将文件内容修改为 1234567891011121314151617module.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;element-plus&quot;, // 引入组件 customName: (name) =&gt; &#123; name = name.slice(3); return `element-plus/lib/components/$&#123;name&#125;`; &#125;, // 不引入样式，因为之后会做主题定制，所以需要引入所有样式的scss文件 &#125;, ], ],&#125;; 测试按需引入是否正确在 src/main.ts 中，引入 element-plus 的样式文件 1import &quot;element-plus/dist/index.css&quot;; 在 src/App.vue 中，添加 script 代码 123&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt; 在 template 中添加一个 el-button 组件 1&lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; App.vue 123456789101112131415&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ... 省略css代码&lt;/style&gt; 运行项目，浏览器访问 el-button 组件就很好的显示在了页面上 把按需引入提取到单独的目录为什么要提取到单独的目录来，有一个好处就是只需要在这里引入一次，并注册成全局的组件之后，就不需要在每个需要用到 element-plus 的组件里面再次引入了。 我一般会在 src 目录下，创建一个 theme 文件夹，专门做按需加载和主题定制 创建一个 theme 文件夹，并在目录下创建一个 index.ts 的文件 将刚才引入 el-button 的代码放到这个文件中，并将组件注册为全局的组件，在这里文件里，我们将导出一个函数，这个函数会作为 Vue 的一个插件，在 main.ts 中通过 app.use() 的方式注册到全局 index.ts 123456import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.use(ElButton);&#125;; main.ts 123456789101112import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;import Element from &quot;./theme&quot;;const app = createApp(App);app.use(store);app.use(router);app.use(Element);app.mount(&quot;#app&quot;); 测试一下我们的提取的按需引入是否正确 删掉刚才在 App.vue 中添加的 script 标签 1234567891011&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 刷新浏览器，发现 el-button 的组件渲染的和之前一样，没有问题 配置 element-plus 的全局属性element-plus 还为我们提供了两个可以全局配置的属性， size 和 zIndex，还是在我们的 theme/index.ts 文件中配置，修改导出的函数，给 app.config.globalProperties.$ELEMENT 属性赋值 1234export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton);&#125;; 然后打开浏览器，可以发现 el-button 的按钮，比刚才小了很多了 配置 i18nElementPlus 组件内部默认使用英语，如果我们希望我们的项目中默认使用中文，就需要对 element-plus 配置 i18n，先来看一个默认英文的例子 在 theme/index.ts 文件中引入 ElCalendar 组件 12345678import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar);&#125;; 在 src/App.vue 中使用 ElCalendar 组件 123456789&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt;&lt;/template&gt; 打开浏览器会发现日历的头部和按钮都是显示的英文 接下来我们配置 i18n，还是在我们的 theme/index.ts 文件中，引入 ElConfigProvider 组件，并在 src/App.vue 中使用 theme/index.ts 123456789import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ...&lt;/style&gt; 再次打开浏览器，就可以看到日历的按钮已经变成中文了，但是日历的头部还是英文的展示，这是因为 element-plus 的中的时间和日期相关的组件，都使用了 dayjs 格式化，所以我们这里想把日历的头部 改成中文还需要引入一下 dayjs 的中文包 在 theme/index.ts 中添加引入 1import &quot;dayjs/locale/zh-cn&quot;; 配置主题定制element-plus 给我们提供了一套默认的主题，同时给我们提供了四种方法，可以进行不同程度的样式自定义。这里只说其中的一种，其他的方式，感兴趣的可以前往官网查阅 通过修改scss变量的方式，替换主题的样式在我们的 src/theme 目录下新建一个 element-variables.scss 的文件，之后我们需要定制的 element-plus 主题的 scss 变量都会在这个文件重写。 不要使用官网推荐的 element-theme 工具，已经很久没有人维护了，在最新版本的node环境下使用会报错。 在我们项目的根目录下找到 node_modules/element-plus/theme-chalk/src/common/var.scss 这个文件，这里面所有后面带有 !default 的就是我们可以修改的所有的 scss 的变量了 比如说我们想要修改一下 primary 的样式，我们查找 var.scss 文件发现，关于 primary 颜色的定义就在第 21 行，$--colors 的初始值就是带有 !default 的， 我们在 element-variables.scss 文件中对 $--colors 重新赋值就可以修改 primary 的颜色 src/theme/element-variables.scss 12345$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: #000, ),); 注意：要通过修改scss变量的方式自定义主题，必须重新设置 font 文件路径 引入 element-plus/packages/theme-chalk/src/index.scss 之后，就可以修改 scss 的变量了 所以我们在 src/theme 文件夹下在新建一个 index.scss 文件，用来引入自定义的主题并处理 font 路径和 element-plus 的 scss 文件 src/theme/index.scss 123@import &quot;./element-variables.scss&quot;;$--font-path: &quot;~element-plus/theme-chalk/fonts&quot;; @import &quot;~element-plus/packages/theme-chalk/src/index&quot;; 在 src/theme/index.ts 文件中引入这个文件 import &quot;./index.scss&quot;; src/theme/index.ts 1234567891011import &#123; App &#125; from &quot;vue&quot;;import &quot;dayjs/locale/zh-cn&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;import &quot;./index.scss&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; 删除 src.main.ts 中引入样式的代码 import &quot;element-plus/dist/index.css&quot;; 刷新浏览器就可以看到我们修改的主题的样式了 配置 scss 全局变量文件在我们的项目开发过程中，不可能只使用 element-plus 的组件和样式，所以我们会需要维护一套我们自己的 scss ，为了样式的统一和以后的好维护，我们应该使用和 element-plus 类似的这种全局变量的方式，定义我们的统一的颜色、边框等等 在 src/assets 目录下新建一个 scss 文件夹，在其中新建以下文件 var.scss 定义全局的变量 mixin.scss 定义全局的混入 fun.scss 定义全局的函数 common.scss 全局的样式，这个文件会定义一些具体的选择器的样式，上面的其他文件中定义都是不会被直接编译出 css 代码的 在 sass-loader中配置成全局scss文件在项目根目录下创建 vue.config.js 文件，并添加 css 配置 vue.config.js 1module.exports = &#123; css: &#123; loaderOptions: &#123; scss: &#123; additionalData: ` @import &quot;~@/assets/scss/var.scss&quot;; @import &quot;~@/assets/scss/mixin.scss&quot;; @import &quot;~@/assets/scss/fun.scss&quot;; `, &#125;, &#125;, &#125;,&#125;; 验证一下全局的 scss 文件是否配置成功 在 src/assets/scss/var.sass 中添加变量 $primary-color: red;，把刚才修改的 src/theme/element-variables 文件中的 primary 的颜色设置成 $primary-color src/assets/scss/var.scss 1$primary-color: red; src/theme/element-variables.scss 1$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: $primary-color, ),); 在 src/assets/scss/fun.scss 文件中添加一个 toRem 函数，在 src/App.vue 中调用这个函数 在 src/App.vue 中添加一个标签 &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt;，在 style 标签里给 div 定义一个样式，使用 $primary-color 变量和 toRem 函数 src/assets/scss/fun.scss 1@function toRem($px) &#123; @return $px / 75px * 1rem;&#125; 实际开发中，如果有需要 px 转 rem 的操作，建议可以使用 postcss 的插件 pxtorem ，可以不用每次都要都要写 toRem()，这里只是用来做一下演示 src/App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 省略其余代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script&gt; // ... 省略js代码&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.bg-red &#123; width: toRem(200px); height: toRem(200px); background: $primary-color;&#125;&lt;/style&gt; 在项目编译的时候给出了以下警告，使用 / 表示除法已经被废弃，应该使用 math.div 方法 修改一下 src/assets/scss/fun.scss 文件 1234@use &quot;sass:math&quot;;@function toRem($px) &#123; @return math.div($px, 75px) * 1rem;&#125; 打开浏览器可以看到红色的按钮，和 div 的样式，宽高已经是 rem 的单位，并且背景也红色 最后，在 src/main.ts 中引入 common.scss 文件 1import &quot;@/assets/scss/common.scss&quot;; 添加 reset.scss 文件在项目开发中，为了减少浏览器在默认行高、页边距和标题字体大小等方面的不一致，需要重置样式表 在 src/assets/scss 下新建 reset.scss 文件 src/assets/scss/reset.scss 12345678910111213141516171819202122232425262728293031323334353637383940414243html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: &#x27;&#x27;; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 在 src/main.ts 中引入 1import &quot;@/assets/scss/reset.scss&quot;; ### 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：配置运行环境","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"第一篇-使用vue-cli 创建Vue3项目","slug":"第一篇-使用vue-cli 创建Vue3项目","date":"2021-09-06T06:24:36.000Z","updated":"2021-09-08T10:07:39.462Z","comments":true,"path":"2021/09/06/第一篇-使用vue-cli 创建Vue3项目/","link":"","permalink":"https://wukang0718.com/2021/09/06/%E7%AC%AC%E4%B8%80%E7%AF%87-%E4%BD%BF%E7%94%A8vue-cli%20%E5%88%9B%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"第一步：安装 nodejs安装已经安装可以跳过到 下一步 nodejs 官网地址：https://nodejs.org/zh-cn/download/ 长期维护版（即稳定版）下选择对应的操作系统点击即可下载，之后一直点击下一步，即可完成安装 安装完成后检查是否安装成功打开命令行窗口 windows系统使用win+R，之后输入 cmd mac 用户，打开 terminal / 终端 输入 node -v 查看 nodejs 版本，输入 npm -v 查看 npm 版本 1234node -v# v14.17.4npm -v# 7.21.1 显示对应的版本就表示安装成功 第二步：安装vue-cli安装已经安装可以跳过到 下一步 vue-cli 官网：https://cli.vuejs.org/zh/guide/installation.html 建议全局安装 在命令行执行以下命令，mac用户需要 sudo 执行 123npm install -g @vue/cli# ORyarn global add @vue/cli 安装完成后检查是否安装成功命令行执行 vue --version 12vue --version# @vue/cli 4.5.13 看到正确的版本号，表示安装成功 第三步：使用脚手架创建项目在命令行执行 vue create &lt;app-name&gt; 命令创建项目，例如，我现在创建一个名叫 cli-create-project 的项目，在命令执行 1vue create cli-create-project 选择 preset 命令行窗口会提示请选择一个 preset，建议选择第三个 Manually select features，选择第一个或者第二个，创建的项目会比较简陋，只有 babel 和 eslint ，项目中必备的 vue-router 等的不会被创建，选择第三项（手动选择功能）,按上下键选择，回车键确认，进入下一步 选择功能 回车之后，命令行窗口就到了选择功能，按上下键切换功能，空格选中和取消选中，回车会进入到下一步。 Choose Vue version 必选，之后会选择使用Vue2还是Vue3 Babel 必选 TypeScript 选中之后，项目会安装typescript的依赖，建议是Vue2的话，就不用选了，Vue3的还是可以使用TypeScript的 Progressive Web App (PWA) Support 可选可不选，在项目中添加pwa支持， 会在项目中添加 Service Workers Router 必选，在项目中安装 vue-router Vuex 按照项目的需求来，会在项目中安装 vuex，一般不是很小的项目的话，都会用到的 CSS Pre-processors 一般都选，安装css的预处理器 Linter / Formatter 必选，安装 eslint 和一个格式化代码的工具会校验和格式化代码 Unit Testing 集成单元测试，看自己情况安装吧 E2E Testing 集成端到端测试，也是看自己情况安装吧 回车进入下一步 选择 vue 版本，这里选择3.x 回车进入下一步 选择是否使用类组件语法，Vue3的话就使用不了，输入 n 回车 选择是否使用Babel与TypeScript一起用于自动检测的填充，使用，输入 Y 回车 选择是否使用 history 模式的路由，是否都是可以的，我就选择使用，输入 Y 回车 选择一个 css 的预处理器，这里按照个人的喜好选择吧，我后续要添加 element-plus 的UI框架，所以就选择 Sass/SCSS (with dart-sass)，回车到下一步 选择一个 lint 和 一个格式化代码的工具，我比较喜欢用 ESLint + Prettier ，就选择这个了,回车到下一步 选择 lint 执行的时机，在保存时执行，或者是在代码提交的时候，需要自动修复，我不需要自动修复，就选择 Lint on save 了，回车到下一步 选择一个单元测试的工具，我用 Jest 比较多，这里就选择 jest，如果在第二步的时候，没有选择 Unit Testing ，就没有这一步 选择一个端到端的测试框架，同样我用 Cypress，比较多，我就选择这个了，同样的，如果在第二步的时候，没有选择 E2E Testing，就没有这一步 选择一个存放插件（eslint、postcss、babel…）配置文件的位置 In dedicated config files 存放在单独的配置文件中，会在项目目录下生成 babel.config.js 之类的文件 In package.json 把插件的配置都写在 packgae.json 文件中 个人喜欢单独文件存放，就选择 In dedicated config files 了，回车到下一步 是否要把这些配置保存为一个将来可复用的 preset。 选择 Y 的话，会把 preset 保存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。 不想保存的话就输入n，回车开始下载项目模版并安装依赖 安装完成，进入项目目录 1cd cli- create-project 这里默认安装的 vue、vue-router 、vuex 的版本都比较低，先升级一下版本 123npm install vue@next vue-router@next vuex@next --save#or yarn add vue@next vue-router@next vuex@next --save 升级完版本之后，运行项目看一下是否可以成功运行 123npm run serve#oryarn serve 启动成功 在浏览器访问 使用 vue-cli 创建 vue3 项目就成功了 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：在项目中添加 element-plus","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"}]},{"title":"vue-router中query参数做自动加密、解密","slug":"vue-router中query参数做自动加密、解密","date":"2021-09-04T10:46:27.000Z","updated":"2021-09-07T12:50:21.685Z","comments":true,"path":"2021/09/04/vue-router中query参数做自动加密、解密/","link":"","permalink":"https://wukang0718.com/2021/09/04/vue-router%E4%B8%ADquery%E5%8F%82%E6%95%B0%E5%81%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/","excerpt":"","text":"vue-router 插件，对vue-router使用中query参数做自动加密、解密仓库地址​ github: https://github.com/wukang0718/vueRouterEncryption ​ gitee: https://gitee.com/wu_kang0718/vueRouterEncryption 使用方式 加密需要依赖 crypto-js 库，安装： npm 1npm install crypto-js --save yarn 1yarn add crypto-js 将utils文件夹放入项目 （最好是放在router目录下 ） 中，在router的初始化文件中，引入utils/query.js的stringifyQuery和parseQuery方法，在new VueRouter是时候传递参数， 修改utils/encryption.js中的baseCryptoCode设置每个项目唯一的值 例：（参考index.js） 1234567891011121314151617import Vue from &quot;vue&quot;import VueRouter from &quot;vue-router&quot;;import &#123; stringifyQuery, parseQuery &#125; from &quot;./utils/query&quot;;Vue.use(VueRouter);const routes = [];const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, stringifyQuery: stringifyQuery, // 序列化query参数 parseQuery: parseQuery, // 反序列化query参数 routes&#125;);export default router 结构 utils/encryption.js 文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js） getEncrypt 加密 对应的解密方法（getDecrypt） getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64） getDecrypt 解密 对应的加密方法（getEncrypt） getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64） utils/query.js 文件提供了序列化和反序列化的方法 stringifyQuery 序列化对象并 加密 parseQuery 解密 反序列化对象 原理 在创建路由的时候，添加两个方法 stringifyQuery: 序列化传入的query参数，方法可以接收一个对象参数 在new Router的时候传递这个属性，在序列化query参数的就执行这个方法，不会执行默认的方法，序列化后在地址栏显示序列化之后的参数 parseQuery: 解析地址栏参数，方法接收一个字符串参数 在new Router的时候传递这个属性，在解析query参数的时候，回执行这个方法，不会在执行默认的方法， 注： 这个方法只解析path中的参数，或者浏览器刷新的时候的地址栏的参数，不会对在query参数对处理，如： 123456this.$router.push(&#123; path: &quot;foo?a=123&quot;, query: &#123; b: 345 &#125;&#125;) 在执行这段代码的时候，parseQuery方法不会对query:&#123;b: 345&#125;进行解析,会解析path:&quot;foo?a=123&quot;中的a=123的字符串 序列化 vue-router在执行createRoute的时候，获取fullPath会执行getFullPath方法 createRouter 方法 会获取在 new VueRouter的时候传递的stringifyQuery方法，如果没有这个方法，就会在getFullPath的时候，使用默认的方法 源码位置：“/vue-router/src/utils/route.js” 12345678910111213141516171819202122232425262728export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || &#x27;/&#x27;, hash: location.hash || &#x27;&#x27;, query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125; getFullPath 方法接收两个参数（路由对象， 序列化query的方法） 源码： 1234567function getFullPath ( &#123; path, query = &#123;&#125;, hash = &#x27;&#x27; &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || &#x27;/&#x27;) + stringify(query) + hash&#125; 反序列化 在调用push的时候，会执行this.router.match方法，match方法会执行normalizeLocation normalizeLocation通过resolveQuery方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法） 反序列化方法会通过router &amp;&amp; router.options.parseQuery获取，如果在new VueRouter的时候传递了parseQuery方法，就是用该方法，如果没有就在resolveQuery方法中使用默认的方法 源码地址：“/vue-router/src/utils/location.js” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === &#x27;string&#x27; ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; return next &#125; else if (next.name) &#123; next = extend(&#123;&#125;, raw) const params = next.params if (params &amp;&amp; typeof params === &#x27;object&#x27;) &#123; next.params = extend(&#123;&#125;, params) &#125; return next &#125; // relative params if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; const parsedPath = parsePath(next.path || &#x27;&#x27;) const basePath = (current &amp;&amp; current.path) || &#x27;/&#x27; const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== &#x27;#&#x27;) &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125;","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"}]},{"title":"为什么微任务比宏任务执行快","slug":"为什么微任务比宏任务执行快","date":"2021-09-04T07:49:41.000Z","updated":"2021-09-07T12:50:13.765Z","comments":true,"path":"2021/09/04/为什么微任务比宏任务执行快/","link":"","permalink":"https://wukang0718.com/2021/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BF%AB/","excerpt":"","text":"为什么微任务比宏任务执行快 微任务叫 microtask 称为 jobs，是由JavaScript自身发起的 宏任务叫 macrotask 称为 task，是由宿主环境发起的 Event Loop中，每一次循环称为tick 主要区别 宏任务（macrotask） 微任务（microtask） 谁发起的 Nodejs/浏览器 JavaScript自身 具体事件 script 标签setTimeout/setIntervalUiRenderingpostMessage/messageChannelsetImmediate/IO PromiseMutationObserverprocess.nextTick 谁先执行 后执行 先执行 会触发新一轮的tick吗 会 不会","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}],"categories":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/categories/vue3/"},{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3","slug":"vue/vue3","permalink":"https://wukang0718.com/categories/vue/vue3/"},{"name":"vue2升级vue3","slug":"vue/vue3/vue2升级vue3","permalink":"https://wukang0718.com/categories/vue/vue3/vue2%E5%8D%87%E7%BA%A7vue3/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"},{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"},{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"ref","slug":"ref","permalink":"https://wukang0718.com/tags/ref/"},{"name":"reactive","slug":"reactive","permalink":"https://wukang0718.com/tags/reactive/"},{"name":"computed","slug":"computed","permalink":"https://wukang0718.com/tags/computed/"},{"name":"effect","slug":"effect","permalink":"https://wukang0718.com/tags/effect/"},{"name":"createApp","slug":"createApp","permalink":"https://wukang0718.com/tags/createApp/"},{"name":"vue2升级vue3","slug":"vue2升级vue3","permalink":"https://wukang0718.com/tags/vue2%E5%8D%87%E7%BA%A7vue3/"},{"name":"build","slug":"build","permalink":"https://wukang0718.com/tags/build/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}