{"meta":{"title":"前端武康","subtitle":"","description":"前端博客 Vue React Node","author":"武康","url":"https://wukang0718.com","root":"/"},"pages":[{"title":"关于","date":"2021-08-30T05:54:04.000Z","updated":"2021-08-30T05:54:20.896Z","comments":true,"path":"about/index.html","permalink":"https://wukang0718.com/about/","excerpt":"","text":""},{"title":"分类","date":"2021-08-30T05:48:12.000Z","updated":"2021-08-30T05:53:39.290Z","comments":true,"path":"categories/index.html","permalink":"https://wukang0718.com/categories/","excerpt":"","text":""},{"title":"标签","date":"2021-08-30T05:51:09.000Z","updated":"2021-08-30T05:56:35.571Z","comments":true,"path":"tags/index.html","permalink":"https://wukang0718.com/tags/","excerpt":"","text":""}],"posts":[{"title":"使用vue-cli 创建Vue3项目","slug":"使用vue-cli-创建Vue3项目","date":"2021-09-06T06:24:36.000Z","updated":"2021-09-06T06:28:40.406Z","comments":true,"path":"2021/09/06/使用vue-cli-创建Vue3项目/","link":"","permalink":"https://wukang0718.com/2021/09/06/%E4%BD%BF%E7%94%A8vue-cli-%E5%88%9B%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"使用vue-cli 创建Vue3项目第一步：安装 nodejs安装已经安装可以跳过到 下一步 nodejs 官网地址：https://nodejs.org/zh-cn/download/ 长期维护版（即稳定版）下选择对应的操作系统点击即可下载，之后一直点击下一步，即可完成安装 安装完成后检查是否安装成功打开命令行窗口 windows系统使用win+R，之后输入 cmd mac 用户，打开 terminal / 终端 输入 node -v 查看 nodejs 版本，输入 npm -v 查看 npm 版本 1234node -v# v14.17.4npm -v# 7.21.1 显示对应的版本就表示安装成功 第二步：安装vue-cli安装已经安装可以跳过到 下一步 vue-cli 官网：https://cli.vuejs.org/zh/guide/installation.html 建议全局安装 在命令行执行以下命令，mac用户需要 sudo 执行 123npm install -g @vue/cli# ORyarn global add @vue/cli 安装完成后检查是否安装成功命令行执行 vue --version 12vue --version# @vue/cli 4.5.13 看到正确的版本号，表示安装成功 第三步：使用脚手架创建项目在命令行执行 vue create &lt;app-name&gt; 命令创建项目，例如，我现在创建一个名叫 cli-create-project 的项目，在命令执行 1vue create cli-create-project 选择 preset 命令行窗口会提示请选择一个 preset，建议选择第三个 Manually select features，选择第一个或者第二个，创建的项目会比较简陋，只有 babel 和 eslint ，项目中必备的 vue-router 等的不会被创建，选择第三项（手动选择功能）,按上下键选择，回车键确认，进入下一步 选择功能 回车之后，命令行窗口就到了选择功能，按上下键切换功能，空格选中和取消选中，回车会进入到下一步。 Choose Vue version 必选，之后会选择使用Vue2还是Vue3 Babel 必选 TypeScript 选中之后，项目会安装typescript的依赖，建议是Vue2的话，就不用选了，Vue3的还是可以使用TypeScript的 Progressive Web App (PWA) Support 可选可不选，在项目中添加pwa支持， 会在项目中添加 Service Workers Router 必选，在项目中安装 vue-router Vuex 按照项目的需求来，会在项目中安装 vuex，一般不是很小的项目的话，都会用到的 CSS Pre-processors 一般都选，安装css的预处理器 Linter / Formatter 必选，安装 eslint 和一个格式化代码的工具会校验和格式化代码 Unit Testing 集成单元测试，看自己情况安装吧 E2E Testing 集成端到端测试，也是看自己情况安装吧 回车进入下一步 选择 vue 版本，这里选择3.x 回车进入下一步 选择是否使用类组件语法，Vue3的话就使用不了，输入 n 回车 选择是否使用Babel与TypeScript一起用于自动检测的填充，使用，输入 Y 回车 选择是否使用 history 模式的路由，是否都是可以的，我就选择使用，输入 Y 回车 选择一个 css 的预处理器，这里按照个人的喜好选择吧，我后续要添加 element-plus 的UI框架，所以就选择 Sass/SCSS (with dart-sass)，回车到下一步 选择一个 lint 和 一个格式化代码的工具，我比较喜欢用 ESLint + Prettier ，就选择这个了,回车到下一步 选择 lint 执行的时机，在保存时执行，或者是在代码提交的时候，需要自动修复，我不需要自动修复，就选择 Lint on save 了，回车到下一步 选择一个单元测试的工具，我用 Jest 比较多，这里就选择 jest，如果在第二步的时候，没有选择 Unit Testing ，就没有这一步 选择一个端到端的测试框架，同样我用 Cypress，比较多，我就选择这个了，同样的，如果在第二步的时候，没有选择 E2E Testing，就没有这一步 选择一个存放插件（eslint、postcss、babel…）配置文件的位置 In dedicated config files 存放在单独的配置文件中，会在项目目录下生成 babel.config.js 之类的文件 In package.json 把插件的配置都写在 packgae.json 文件中 个人喜欢单独文件存放，就选择 In dedicated config files 了，回车到下一步 是否要把这些配置保存为一个将来可复用的 preset。 选择 Y 的话，会把 preset 保存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。 不想保存的话就输入n，回车开始下载项目模版并安装依赖 安装完成，进入项目目录 1cd cli- create-project 这里默认安装的 vue、vue-router 、vuex 的版本都比较低，先升级一下版本 123npm install vue@next vue-router@next vuex@next --save#or yarn add vue@next vue-router@next vuex@next --save 升级完版本之后，运行项目看一下是否可以成功运行 123npm run serve#oryarn serve 启动成功 在浏览器访问 使用 vue-cli 创建 vue3 项目就成功了 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"vue-router中query参数做自动加密、解密","slug":"vue-router中query参数做自动加密、解密","date":"2021-09-04T10:46:27.000Z","updated":"2021-09-04T10:48:50.902Z","comments":true,"path":"2021/09/04/vue-router中query参数做自动加密、解密/","link":"","permalink":"https://wukang0718.com/2021/09/04/vue-router%E4%B8%ADquery%E5%8F%82%E6%95%B0%E5%81%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/","excerpt":"","text":"vue-router 插件，对vue-router使用中query参数做自动加密、解密仓库地址​ github: https://github.com/wukang0718/vueRouterEncryption ​ gitee: https://gitee.com/wu_kang0718/vueRouterEncryption 使用方式 加密需要依赖 crypto-js 库，安装： npm 1npm install crypto-js --save yarn 1yarn add crypto-js 将utils文件夹放入项目 （最好是放在router目录下 ） 中，在router的初始化文件中，引入utils/query.js的stringifyQuery和parseQuery方法，在new VueRouter是时候传递参数， 修改utils/encryption.js中的baseCryptoCode设置每个项目唯一的值 例：（参考index.js） 1234567891011121314151617import Vue from &quot;vue&quot;import VueRouter from &quot;vue-router&quot;;import &#123; stringifyQuery, parseQuery &#125; from &quot;./utils/query&quot;;Vue.use(VueRouter);const routes = [];const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, stringifyQuery: stringifyQuery, // 序列化query参数 parseQuery: parseQuery, // 反序列化query参数 routes&#125;);export default router 结构 utils/encryption.js 文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js） getEncrypt 加密 对应的解密方法（getDecrypt） getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64） getDecrypt 解密 对应的加密方法（getEncrypt） getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64） utils/query.js 文件提供了序列化和反序列化的方法 stringifyQuery 序列化对象并 加密 parseQuery 解密 反序列化对象 原理 在创建路由的时候，添加两个方法 stringifyQuery: 序列化传入的query参数，方法可以接收一个对象参数 在new Router的时候传递这个属性，在序列化query参数的就执行这个方法，不会执行默认的方法，序列化后在地址栏显示序列化之后的参数 parseQuery: 解析地址栏参数，方法接收一个字符串参数 在new Router的时候传递这个属性，在解析query参数的时候，回执行这个方法，不会在执行默认的方法， 注： 这个方法只解析path中的参数，或者浏览器刷新的时候的地址栏的参数，不会对在query参数对处理，如： 123456this.$router.push(&#123; path: &quot;foo?a=123&quot;, query: &#123; b: 345 &#125;&#125;) 在执行这段代码的时候，parseQuery方法不会对query:&#123;b: 345&#125;进行解析,会解析path:&quot;foo?a=123&quot;中的a=123的字符串 序列化 vue-router在执行createRoute的时候，获取fullPath会执行getFullPath方法 createRouter 方法 会获取在 new VueRouter的时候传递的stringifyQuery方法，如果没有这个方法，就会在getFullPath的时候，使用默认的方法 源码位置：“/vue-router/src/utils/route.js” 12345678910111213141516171819202122232425262728export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || &#x27;/&#x27;, hash: location.hash || &#x27;&#x27;, query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125; getFullPath 方法接收两个参数（路由对象， 序列化query的方法） 源码： 1234567function getFullPath ( &#123; path, query = &#123;&#125;, hash = &#x27;&#x27; &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || &#x27;/&#x27;) + stringify(query) + hash&#125; 反序列化 在调用push的时候，会执行this.router.match方法，match方法会执行normalizeLocation normalizeLocation通过resolveQuery方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法） 反序列化方法会通过router &amp;&amp; router.options.parseQuery获取，如果在new VueRouter的时候传递了parseQuery方法，就是用该方法，如果没有就在resolveQuery方法中使用默认的方法 源码地址：“/vue-router/src/utils/location.js” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === &#x27;string&#x27; ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; return next &#125; else if (next.name) &#123; next = extend(&#123;&#125;, raw) const params = next.params if (params &amp;&amp; typeof params === &#x27;object&#x27;) &#123; next.params = extend(&#123;&#125;, params) &#125; return next &#125; // relative params if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; const parsedPath = parsePath(next.path || &#x27;&#x27;) const basePath = (current &amp;&amp; current.path) || &#x27;/&#x27; const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== &#x27;#&#x27;) &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125;","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"}]},{"title":"为什么微任务比宏任务执行快","slug":"为什么微任务比宏任务执行快","date":"2021-09-04T07:49:41.000Z","updated":"2021-09-04T07:55:37.599Z","comments":true,"path":"2021/09/04/为什么微任务比宏任务执行快/","link":"","permalink":"https://wukang0718.com/2021/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BF%AB/","excerpt":"","text":"为什么微任务比宏任务执行快 微任务叫 microtask 称为 jobs，是由JavaScript自身发起的 宏任务叫 macrotask 称为 task，是由宿主环境发起的 Event Loop中，每一次循环称为tick 主要区别 宏任务（macrotask） 微任务（microtask） 谁发起的 Nodejs/浏览器 JavaScript自身 具体事件 script 标签setTimeout/setIntervalUiRenderingpostMessage/messageChannelsetImmediate/IO PromiseMutationObserverprocess.nextTick 谁先执行 后执行 先执行 会触发新一轮的tick吗 会 不会","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"},{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"},{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}