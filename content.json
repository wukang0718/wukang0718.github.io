{"meta":{"title":"前端武康","subtitle":"","description":"前端博客 Vue React Node","author":"武康","url":"https://wukang0718.com","root":"/"},"pages":[{"title":"分类","date":"2021-08-30T05:48:12.000Z","updated":"2021-08-30T05:53:39.290Z","comments":true,"path":"categories/index.html","permalink":"https://wukang0718.com/categories/","excerpt":"","text":""},{"title":"标签","date":"2021-08-30T05:51:09.000Z","updated":"2021-08-30T05:56:35.571Z","comments":true,"path":"tags/index.html","permalink":"https://wukang0718.com/tags/","excerpt":"","text":""},{"title":"关于","date":"2021-08-30T05:54:04.000Z","updated":"2021-08-30T05:54:20.896Z","comments":true,"path":"about/index.html","permalink":"https://wukang0718.com/about/","excerpt":"","text":""}],"posts":[{"title":"第五篇-Vue3项目中集成axios","slug":"第五篇-Vue3项目中集成axios","date":"2021-09-10T01:32:53.000Z","updated":"2021-09-10T01:33:19.669Z","comments":true,"path":"2021/09/10/第五篇-Vue3项目中集成axios/","link":"","permalink":"https://wukang0718.com/2021/09/10/%E7%AC%AC%E4%BA%94%E7%AF%87-Vue3%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90axios/","excerpt":"","text":"什么是 axios？Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。开箱即用的工具 这也是 Vue 官方推荐使用的发送 ajax 请求的工具 axios有哪些特性 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装 axios123npm install axios --save# oryarn add axios --save 在 src/App.vue 中使用一下 axios，添加以下代码 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;div&gt; &lt;h1&gt;请求的内容&lt;/h1&gt; &lt;div&gt;&#123;&#123; result &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;!-- 忽略其他代码 --&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;// 忽略其他代码import axios from &quot;axios&quot;;const result = ref(&quot;&quot;);axios.get(location.href).then((&#123; data &#125;) =&gt; &#123; result.value = data;&#125;);&lt;/script&gt; 在浏览器中就可以查看到我们网站的代码了 在日常项目的开发中，通常会有多个后端的服务，而每个服务会有自己的 url 地址、token之类的，通常是使用单独的 axios 的实例处理对应的服务，这就需要我们封装多个 axios 的实例 封装 axios在 src 目录下新建一个 axios 文件夹，在其中新建一个 index.ts 文件，这个文件就是用来导出封装好的 axios 使用 axios.create() 方法就可以创建一个 axios 的实例 axios 可以设置全局默认的配置，这些配置会被每个实例共享，实例可以覆盖这些配置 设置全局的参数 设置全局的接口超时时间 timeout，这个时间是对所有实例通用的 src/axios/index.ts 12import axios from &quot;axios&quot;;axios.defaults.timeout = 60 * 1000; // 设置超时时间是1分钟 创建 axios的实例假设我们的项目中会用到两个服务(a, b)的接口 接口地址/环境 development 开发环境 t 测试环境 production 生产环境 服务a http://a.dev.server.com http://a.test.server.com http://a.prod.server.com 服务b http://b.dev.server.com http://b.test.server.com http://b.prod.server.com 同一个服务根据不同的运行环境需要使用不同的接口地址，这种情况最好是把接口地址写在环境文件中 .env.development 中添加 12VUE_APP_A_BASE_URL=http://a.dev.server.comVUE_APP_B_BASE_URL=http://b.dev.server.com .env.t 中添加 12VUE_APP_A_BASE_URL=http://a.test.server.comVUE_APP_B_BASE_URL=http://b.test.server.com .env.production 中添加 12VUE_APP_A_BASE_URL=http://a.prod.server.comVUE_APP_B_BASE_URL=http://b.prod.server.com 在 src/axios/index.ts 文件中就可以通过 process.env.VUE_APP_A_BASE_URL 和 process.env.VUE_APP_B_BASE_URL 取到对应的服务地址 src/axios/index.ts 添加 1234567export const aService = axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL,&#125;);export const bService = axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL,&#125;); 创建并导出的两个 axios 的服务分别用来处理对应的两个后端服务的接口 设置请求拦截器请求拦截器可以处理哪些问题 在请求发送之前需要处理的事情，都可以在请求拦截器中处理 例如每个请求都要在请求头中添加 token 在请求发送之前遇到的错误都可以在请求拦截器中被处理 语法axios 设置请求拦截器的语法，要为实例添加拦截器只要把 axios 替换成对应的实例就可以了 1axios.interceptors.request.use(onFulfilled, onRejected); onFulfilled 函数，接收一个 config 的参数，可以对 config 进行修改，最后返回这个 config onRejected 函数，处理在请求发送之前的错误 请求拦截器的执行顺序是先添加的后执行 封装在 src/axios 下新建文件夹 interceptors 再 interceptors 新建一个 request 文件夹，这个文件夹中保存所有请求拦截器 请求错误处理的拦截器 把错误拦截器作为第一个拦截器，可以拦截到所有请求发出之前的错误，在这个也可以给服务器上报错误日志 同一个拦截器中的 onRejected 函数处理不到 onFulfilled 中的异常，所以最后一个请求拦截器的 onRejected 函数是不会被执行的 在 src/axios/interceptors/request 文件夹下新建 error.ts 文件，这个文件中做对请求开始之前的错误处理 src/axios/interceptors/request/error.ts 1234export default function handleRequestError(error: any): Promise&lt;any&gt; &#123; // 可以给服务器上报错误 return Promise.reject(error);&#125; eslint 提示 Unexpected any. Specify a different type. 在项目根目录下的 .eslintrc.js 文件中 rules 中添加一行 &quot;@typescript-eslint/no-explicit-any&quot;: &quot;off&quot;, eslint 提示 Argument ‘error’ should be typed with a non-any type. 在项目根目录下的 .eslintrc.js 文件中 rules 中添加一行 &quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;, 在 src/axios/interceptors/request 文件夹下新建 index.ts 文件，这个文件提供两个添加请求拦截器的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; AxiosInstance, AxiosRequestConfig &#125; from &quot;axios&quot;;import handleRequestError from &quot;./error&quot;;/** * 给axios的实例添加拦截器 * @param axiosService axios 的实例 * @param requestInterceptorArray 需要添加在实例上的拦截器 二维数组[[拦截器的onFulfilled, 拦截器的onRejected],[...]] * @returns 返回传入的axios的实例 */export function useBaseRequestInterceptor( axiosService: AxiosInstance, requestInterceptorArray: [ (config: AxiosRequestConfig) =&gt; AxiosRequestConfig, ((error: any) =&gt; any) | undefined ][]): AxiosInstance &#123; requestInterceptorArray.forEach((interceptor) =&gt; axiosService.interceptors.request.use(...interceptor) ); return axiosService;&#125;/** * 给axios的实例添加拦截器 * 在所有拦截器之前会添加一个错误拦截器 * @param axiosService axios 的实例 * @param requestInterceptorArray 需要添加在实例上的拦截器 一维数组，只处理onFulfilled函数 * @returns 返回传入的axios的实例 */export default function useRequestInterceptor( axiosService: AxiosInstance, requestInterceptorArray: Array&lt; (config: AxiosRequestConfig) =&gt; AxiosRequestConfig &gt; = []) &#123; const interceptors: [ (config: AxiosRequestConfig) =&gt; AxiosRequestConfig, undefined ][] = requestInterceptorArray.map((interceptor) =&gt; [interceptor, undefined]); return useBaseRequestInterceptor(axiosService, [ [(config: AxiosRequestConfig) =&gt; config, handleRequestError], ...interceptors, ]);&#125; 给 aService 和 bService 添加拦截器 src/axios/index.ts 12345678910111213import useRequestInterceptor from &quot;./interceptors/request&quot;;export const aService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;));export const bService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;)); 在 headers 中添加 token 的请求拦截器 在 src/axios/interceptors/request 文件夹下新建 token.ts 文件 1234567891011121314151617181920212223import &#123; AxiosRequestConfig &#125; from &quot;axios&quot;;/** * 处理 a 服务的token * @param config 请求的axios参数 * @returns 处理后的请求的axios参数 */export function handleAServiceRequestToken(config: AxiosRequestConfig) &#123; const token = &quot;a-service-token&quot;; // 这里要根据项目获取真实的token，从vuex或者本地存储中获取 config.headers[&quot;token&quot;] = token; return config;&#125;/** * 处理 b 服务的token * @param config 请求的axios参数 * @returns 处理后的请求的axios参数 */export function handleBServiceRequestToken(config: AxiosRequestConfig) &#123; const token = &quot;b-service-token&quot;; // 这里要根据项目获取真实的token，从vuex或者本地存储中获取 config.headers[&quot;token&quot;] = token; return config;&#125; 给 aService 和 bService 添加 token 拦截器 123456789101112131415161718import &#123; handleAServiceRequestToken, handleBServiceRequestToken,&#125; from &quot;./interceptors/request/token&quot;;export const aService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleBServiceRequestToken]); 还有其他需要在请求拦截器做的，都可以按照这种方式添加 设置响应拦截器响应拦截器可以处理哪些问题响应拦截器会在请求成功或失败之后调用 请求的错误 在这里判断服务器返回的数据是否有效，无效数据可以当作异常处理 如果接口返回的是文件可以在这里完成文件的下载 等等。。。 语法axios 设置响应拦截器的语法，要为实例添加拦截器只要把 axios 替换成对应的实例就可以了 1axios.interceptors.response.use(onFulfilled, onRejected); onFulfilled 函数，接收一个 AxiosResponse 的返回结果，可以对处理返回的接口进行修改，最后返回一个结果 onRejected 函数，处理请求异常的错误 响应拦截器的执行顺序是先添加的先执行 建议在拦截器中返回 result ，方便后续插拔拦截器的处理，可以考虑在错误拦截器之前的最后一个拦截器中返回 result.data 封装在 src/axios/interceptors 下新建一个 response 文件夹，这个文件夹中保存所有响应拦截器 同一个拦截器中的 onRejected 函数处理不到 onFulfilled 中的异常，所以第一个响应拦截器的 onRejected 函数是不会被执行的 响应错误处理的拦截器 在 src/axios/interceptors/response 文件夹下新建 error.ts 文件，这个文件中做对请求响应之后的错误拦截 把错误拦截器作为最后一个拦截器，可以拦截到所有响应拦截器中的错误 src/axios/interceptors/response/error.ts 123456789101112import &#123; ElMessage &#125; from &quot;element-plus&quot;;/** * 处理 axios 实例的响应错误 * @param error 响应错误消息 * @returns rejected 状态的promise */export default function handleResponseError(error: any): Promise&lt;any&gt; &#123; // 给服务器上传错误日志 ElMessage.error(error); return Promise.reject(error);&#125; 在 src/axios/interceptors/response 文件夹下新建 index.ts 文件，这个文件提供两个添加响应拦截器的方法 1234567891011121314151617181920212223242526272829303132333435363738394041import &#123; AxiosInstance, AxiosResponse &#125; from &quot;axios&quot;;import handleResponseError from &quot;./error&quot;;/** * 给axios的实例添加拦截器 * @param axiosService axios 的实例 * @param responseInterceptorArray 需要添加在实例上的拦截器 二维数组[[拦截器的onFulfilled, 拦截器的onRejected],[...]] * @returns 返回传入的axios的实例 */export function useBaseResponseInterceptor( axiosService: AxiosInstance, responseInterceptorArray: [ (result: AxiosResponse) =&gt; any, ((error: any) =&gt; any) | undefined ][]): AxiosInstance &#123; responseInterceptorArray.forEach((interceptor) =&gt; axiosService.interceptors.response.use(...interceptor) ); return axiosService;&#125;/** * 给axios的实例添加拦截器 * 在所有拦截器之前会添加一个错误拦截器 * @param axiosService axios 的实例 * @param responseInterceptorArray 需要添加在实例上的拦截器 一维数组，只处理onFulfilled函数 * @returns 返回传入的axios的实例 */export default function useResponseInterceptor( axiosService: AxiosInstance, responseInterceptorArray: Array&lt;(result: AxiosResponse) =&gt; any&gt; = []) &#123; const interceptors: [(result: AxiosResponse) =&gt; any, undefined][] = responseInterceptorArray.map((interceptor) =&gt; [interceptor, undefined]); return useBaseResponseInterceptor(axiosService, [ ...interceptors, [(res: AxiosResponse) =&gt; res, handleResponseError], ]);&#125; 给 aService 和 bService 添加响应拦截器 src/axios/index.ts 123456789101112131415161718192021import useResponseInterceptor from &quot;./interceptors/response&quot;;export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [] ), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [] ), [handleBServiceRequestToken]); 处理后端返回的数据，假设后端返回的 json 中有 code 字段，且只有 200 表示成功，其他的全部按照异常处理，如果异常的话会有 message 字段返回异常信息，在 src/axios/interceptors/response 下新建 filterResponse.ts 文件 src/axios/interceptors/response/filterResponse.ts 12345678910111213141516171819import &#123; AxiosResponse &#125; from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;/** * 对服务端返回的数据处理 * code !== 200 的都是有异常的 * @param response axios 响应消息 * @returns */export default function handleResponseFilter( response: AxiosResponse): AxiosResponse | Promise&lt;AxiosResponse&gt; &#123; const &#123; data &#125; = response; if (data.code !== 200) &#123; ElMessage.error(data.message); return Promise.reject(response); &#125; return response;&#125; src/axios/index.ts 123456789101112131415161718192021import handleResponseFilter from &quot;./interceptors/response/filterResponse&quot;;export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleResponseFilter] ), [handleAServiceRequestToken]);export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleResponseFilter] ), [handleBServiceRequestToken]); 其他响应拦截器也可以使用这种方式添加 接口请求中展示loading 根据具体项目看要不要添加这个拦截器，这里用来做演示 在请求发出后 500ms 内如果收到了响应就不展示 loading，如果超过 500ms 就展示 loading，在接口响应之后关闭 loading。 在 src/axios 下创建一个 utils 文件夹，在其中新建一个loading.ts 文件，用来显示和关闭 loading src/axios/utils/loading.ts 123456789101112131415161718192021222324252627import &#123; ElLoading, ILoadingInstance &#125; from &quot;element-plus&quot;;let loadingCount = 0;let loading: ILoadingInstance | null = null;/** * 500ms 之后展示loading */export function showLoading(): NodeJS.Timeout &#123; loadingCount++; return setTimeout(() =&gt; &#123; if (!loading &amp;&amp; loadingCount) &#123; loading = ElLoading.service(); &#125; &#125;, 500);&#125;/** * 如果没有loading中的接口，就关闭loading */export function hideLoading() &#123; loadingCount--; if (loadingCount === 0 &amp;&amp; loading) &#123; loading.close(); loading = null; &#125;&#125; 在 src/axios/interceptors/request 和 src/axios/interceptors/response 文件夹下新建 loading.ts 文件，在 src/axios/utils 下新建 constants.ts 文件，用来存放常量 src/axios/utils/constants.ts 1export const HEADER_NO_LOADING = &quot;NO-LOADING&quot;; // 请求头中添加请求不展示loading的字段 src/axios/interceptors/request/loading.ts 12345678910111213141516171819import &#123; AxiosRequestConfig &#125; from &quot;axios&quot;;import &#123; showLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;../../utils/constants&quot;;/** * 处理 请求时展示 loading 的拦截器 * @param config * @returns */export default function handleRequestLoading( config: AxiosRequestConfig): AxiosRequestConfig &#123; const &#123; headers &#125; = config; // 如果 headers 中有 &quot;NO-LOADING&quot;: true 就不展示loading if (!headers[HEADER_NO_LOADING]) &#123; showLoading(); &#125; return config;&#125; src/axios/interceptors/response/loading.ts 123456789101112131415161718192021import &#123; AxiosResponse &#125; from &quot;axios&quot;;import &#123; hideLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;../../utils/constants&quot;;/** * 处理响应成功之后关闭loading的拦截器 * @param result * @returns */export default function handleResponseLoading( result: AxiosResponse): AxiosResponse &#123; const &#123; config: &#123; headers &#125;, &#125; = result; // 如果 headers 中有 &quot;NO-LOADING&quot;: true 就不处理loading if (!headers[HEADER_NO_LOADING]) &#123; hideLoading(); &#125; return result;&#125; 如果带有loading的请求出现了异常，要在 error 拦截器中关闭 loading src/axios/interceptors/response/error.ts 1234567891011121314151617181920import &#123; AxiosError &#125; from &quot;axios&quot;;import &#123; ElMessage &#125; from &quot;element-plus&quot;;import &#123; hideLoading &#125; from &quot;../../utils/loading&quot;;import &#123; HEADER_NO_LOADING &#125; from &quot;@/axios/utils/constants&quot;;/** * 处理 axios 实例的响应错误 * @param error 响应错误消息 * @returns rejected 状态的promise */export default function handleResponseError( error: AxiosError): Promise&lt;AxiosError&gt; &#123; if (!error.config.headers[HEADER_NO_LOADING]) &#123; hideLoading(); &#125; // 给服务器上传错误日志 ElMessage.error(error.message); return Promise.reject(error);&#125; src/axios/index.ts 12345678910111213141516171819202122232425262728import handleRequestLoading from &quot;./interceptors/request/loading&quot;;import handleResponseLoading from &quot;./interceptors/response/loading&quot;;/** * 给a服务器发送请求的axios实例 */export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_A_BASE_URL, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleAServiceRequestToken, handleRequestLoading]);/** * 给b服务器发送请求的axios实例 */export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: process.env.VUE_APP_B_BASE_URL, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleBServiceRequestToken, handleRequestLoading]); loading的拦截器就加完了，其他的项目中需要的拦截器也可以按照这种方式加入 配置反向代理如果项目开发中，后端的接口提供了跨域请求的支持，那这一步就可以不做了。 但是通常在项目开发中，后端的接口不会提供跨域请求的支持，这个时候就需要我们对请求做一个反向代理，webpack 通过 devServer.proxy 内置了这样的服务。 在根目录的 vue.config.js 文件中添加配置即可 例：给 a、b 服务配置代理 / 代理到 http://localhost:8082 （本地的服务启动的是多少就代理到多少） 首先把 a、b 两个服务的 axios 实例创建时的 baseURL 改成唯一的前缀 src/axios.index.ts 12345678910111213141516171819202122232425/** * 给a服务器发送请求的axios实例 */export const aService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: &quot;/aServer&quot;, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleAServiceRequestToken, handleRequestLoading]);/** * 给b服务器发送请求的axios实例 */export const bService = useRequestInterceptor( useResponseInterceptor( axios.create(&#123; baseURL: &quot;/bServer&quot;, &#125;), [handleResponseLoading, handleResponseFilter] ), [handleBServiceRequestToken, handleRequestLoading]); 然后在 vue.config.js 中配置对应的代理 vue.config.js 123456789101112131415161718192021222324module.exports = &#123; // ... 其他配置 devServer: &#123; // ... proxy: &#123; &quot;/aServer&quot;: &#123; target: process.env.VUE_APP_A_BASE_URL, changeOrigin: true, secure: false, pathRewrite: &#123; &quot;/aServer&quot;: &quot;&quot;, &#125;, &#125;, &quot;/bServer&quot;: &#123; target: process.env.VUE_APP_B_BASE_URL, changeOrigin: true, secure: false, pathRewrite: &#123; &quot;/bServer&quot;: &quot;&quot;, &#125;, &#125;, &#125;, &#125;,&#125; 这样在启动开发环境的时候，就对我们的请求做了反向代理，避免了跨域问题的产生 在项目上线的时候，一般会用一个静态资源服务器做前端入口，比如 nginx，那就可以在 nginx 上做反向代理 上线时候的反向代理用 nginx 做反向代理，一般会在项目根目录有一个 deployment 的文件夹，会存放一项目上线用到的配置文件，比如 nginx 的配置文件 在项目根目录下新建 deployment 文件夹，并在其中新建 test 和 prod 两个文件夹，在建立一个 nginx.conf.tmp 文件，这个文件作为我们生成 nginx.conf 的模版文件，需要根据自己项目的部署情况修改参数。 deployment/nginx.conf.tmp 12345678910111213141516171819server &#123; listen 80; root /usr/share/nginx/html/dist; # 上线服务器存放的位置 # 默认请求 location / &#123; try_files $uri $uri/ /index.html; # 解决history路由刷新404的问题 &#125; location ~ .*\\.(js|css)$ &#123; expires 30d; # 静态资源设置强缓存 &#125; # proxy_pass placeholder # 禁止访问 .htxxx 文件 location ~ /.ht &#123; deny all; &#125;&#125; 在新建一个 genNginxConf.js 这个文件可以根据第一个参数创建对应环境的 default.conf 文件，这是部署项目用到的 nginx 的配置文件 deployment/genNginxConf.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* eslint-disable @typescript-eslint/no-var-requires */const fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const dotenv = require(&quot;dotenv&quot;);const dotenvExpand = require(&quot;dotenv-expand&quot;);const configFile = path.join(__dirname, &quot;../vue.config.js&quot;);const nginxFileName = &quot;default.conf&quot;;const configBaseFile = path.join(__dirname, &quot;./nginx.conf.tmp&quot;);const mode = process.argv[2];let filePath;let envPath;if (mode === &quot;t&quot; || mode === &quot;test&quot;) &#123; filePath = path.join(__dirname, &quot;test&quot;, nginxFileName); envPath = path.join(__dirname, &quot;../.env.t&quot;);&#125; else if (mode === &quot;prod&quot;) &#123; filePath = path.join(__dirname, &quot;prod&quot;, nginxFileName); envPath = path.join(__dirname, &quot;../.env.production&quot;);&#125; else &#123; console.log(`没有对应的模式：$&#123;mode&#125;`); process.exit(1);&#125;// 加载环境变量const env = dotenv.config(&#123; path: envPath &#125;);dotenvExpand(env);let proxyPass = ` # 配置反向代理`;if (fs.statSync(configFile).isFile()) &#123; const webpackConfig = require(configFile); const proxy = webpackConfig?.devServer?.proxy; if (proxy) &#123; for (const [k, &#123; target, pathRewrite &#125;] of Object.entries(proxy)) &#123; let metaPath = k; if (pathRewrite) &#123; Object.keys(pathRewrite).forEach((p) =&gt; &#123; metaPath = metaPath.replace(p, pathRewrite[p]); &#125;); &#125; proxyPass += ` location $&#123;k&#125; &#123; proxy_pass $&#123;target&#125;$&#123;metaPath&#125;; &#125; `; &#125; &#125; else &#123; console.log(&quot;没有配置 devServer.proxy，不需要设置代理&quot;); &#125;&#125; else &#123; console.log(&quot;没有 vue.config.js 文件，不需要设置代理&quot;);&#125;const tmpStr = fs.readFileSync(configBaseFile, &#123; encoding: &quot;utf8&quot; &#125;);fs.writeFileSync( filePath, tmpStr.replace(&quot;# proxy_pass placeholder&quot;, proxyPass));console.log(&quot;nginx 配置文件生成&quot;); 命令行执行 1node ./deployment/genNginxConf.js t 就可以看到 deployment/test/default.conf 文件被创建出来 把刚才的命令添加到 package.json 中的 scripts 中，方便之后的执行 12&quot;gennginx:t&quot;: &quot;node ./deployment/genNginxConf.js t&quot;,&quot;gennginx:prod&quot;: &quot;node ./deployment/genNginxConf.js prod&quot; 执行一下下面的命令，在 deployment/prod 下也会生层 default.conf 文件 123npm run gennginx:prod# oryarn gennginx:prod 修改一下 build 和 build:t 命令，在执行这个命令的时候，可以同时生成新的 nginx 配置文件 12&quot;build&quot;: &quot;vue-cli-service build &amp;&amp; npm run gennginx:prod&quot;,&quot;build:t&quot;: &quot;vue-cli-service build --mode t &amp;&amp; npm run gennginx:t&quot;, 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第四篇-添加工具规范 git commit message","slug":"第四篇-添加工具规范-git-commit-message","date":"2021-09-08T10:05:13.000Z","updated":"2021-09-10T01:35:04.948Z","comments":true,"path":"2021/09/08/第四篇-添加工具规范-git-commit-message/","link":"","permalink":"https://wukang0718.com/2021/09/08/%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%B7%BB%E5%8A%A0%E5%B7%A5%E5%85%B7%E8%A7%84%E8%8C%83-git-commit-message/","excerpt":"","text":"Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。 一般来说，commit message 应该清晰明了，说明本次提交的目的，是新增了一个功能或者修复了一个bug 之类的，但是随着项目组人员增多，仅靠口头的约束有时候还是会出错的，所以我们需要通过工具来帮助规范团队的 commit message。 规范的 commit message每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt;// 空一行&lt;footer&gt; HeaderHeader部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 typetype用于说明 commit 的类别，可以使用以下标识 1234567891011feat：新功能（feature）fix：修补bugdocs：文档（documentation）style： 格式（不影响代码运行的变动）refactor：重构（即不是新增功能，也不是修改bug的代码变动）perf：优化相关，比如提升性能、体验test：增加测试build：构建ci：更改ci configurationchore：构建过程或辅助工具的变动revert：撤销commit/回滚版本 如果 type 为 feat 和 fix，则该 commit 将肯定出现在 Change log 之中。其他情况默认不加入，可以修改，建议不要。 scopescope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 subjectsubject是 commit 目的的简短描述，不超过50个字符。有以下限制 123以动词开头，使用第一人称现在时，比如change，而不是changed或changes第一个字母小写结尾不加句号（.） BodyBody 部分是对本次 commit 的详细描述，可以分成多行。使用 git commit 会弹出多行编辑器 有两个注意点。 使用第一人称现在时，比如使用change而不是changed或changes。 应该说明代码变动的动机，以及与以前行为的对比。 FooterFooter 部分只用于两种情况。 不兼容变动如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 关闭 Issue如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 123fix #1# 关闭多个fix #1, #2 validate-commit-msgvalidate-commit-msg 是什么?一个可以校验 commit message 的二进制文件 安装 validate-commit-msg123npm install validate-commit-msg --save-dev#oryarn add validate-commit-msg --dev validate-commit-msg 的配置可以通过项目根目录下的 .vcmrc 文件，或者在 package.json 中修改 .vcmrc 文件内容是一个正确的 json 格式 validate-commit-msg 提供了默认配置，一般项目开发不需要修改这个 123456789101112131415&#123; &quot;types&quot;: [&quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot;], &quot;scope&quot;: &#123; &quot;required&quot;: false, &quot;allowed&quot;: [&quot;*&quot;], &quot;validate&quot;: false, &quot;multiple&quot;: false &#125;, &quot;warnOnFail&quot;: false, &quot;maxSubjectLength&quot;: 100, &quot;subjectPattern&quot;: &quot;.+&quot;, &quot;subjectPatternErrorMsg&quot;: &quot;subject does not match subject pattern!&quot;, &quot;helpMessage&quot;: &quot;&quot;, &quot;autoFix&quot;: false&#125; 在 package.json 中修改配置 1234567&#123; &quot;config&quot;: &#123; &quot;validate-commit-msg&quot;: &#123; /* 这里写配置的参数 */ &#125; &#125;&#125; .vcmrc 文件的优先级更高，如果 .vcmrc 文件不存在，才会从 package.json 中读取 huskyhusky是什么？husky 是一个 Git Hook 工具。husky 其实就是一个为 git 客户端增加 hook 的工具。将其安装到所在仓库的过程中它会自动在 .git/ 目录下增加相应的钩子实现在pre-commit阶段就执行一系列流程保证每一个commit 的正确性。 安装 husky不同的包管理工具使用不一样的安装方法：官方文档 123npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2 执行之后会在项目根目录生成 .husky 目录，目录下会有一个 pre-commit 文件，把文件中的 npm test 修改为 npm run lint，如果你的项目中没有使用 eslint，可以把这个文件直接改名成 commit-msg，把文件中的 npm test 修改为 npx validate-commit-msg。 将 pre-commit 文件复制两份命名为 commit-msg 和 pre-push commit-msg 文件中的 npm run lint 修改为 npx validate-commit-msg pre-push 文件中的 npm run lint 修改为 npm run test:unit，如果你的项目没有使用单元测试可以不需要这个文件 pre-commit 会在输入提交信息之前调用，校验 eslint commit-msg 输入了提交信息，如果校验出错，放弃提交 pre-push git push 执行的时候 更新了远程引用但尚未推送到远程时被调用 测试一下 validate-commit-msg 和 husky 是否生效 回到项目根目录下执行 12git add .git commit -m &quot;随便提交点&quot; 出现以下信息代表 commit-msg 钩子中执行的 validate-commit-msg 生效了 123AINVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; !随便提交点husky - commit-msg hook exited with code 1 (error) 做一次正确的提交，commit msg 应该必须包含 type : 和 subject，scope 是可选的 12git commit -m &quot;chore: 添加husky和validate-commit-msg校验commit msg&quot;git push CommitizenCommitizen 是什么?Commitizen 是一个撰写合格 Commit message 的工具。 安装 Commitizen123npm install commitizen --save-dev#oryarn add commitizen --dev 初始化项目中使用 cz-conventional-changelog 适配器 1234# npm 包管理工具执行npx commitizen init cz-conventional-changelog --save-dev --save-exact# yarn 包管理工具执行npx commitizen init cz-conventional-changelog --yarn --dev --exact package.json 文件中会自动添加 commitizen 配置 12345&quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot; &#125;&#125; 以后，凡是用到git commit命令，一律改为使用 cz。这时，就会出现选项，用来生成符合格式的 Commit message。 测试一下 12git add .npx cz 使用 git log 可以查看刚才的 commit message 还可以在 package.json 中添加更加方便的执行命令，在 package.json 的 scripts 中添加 12&quot;cz&quot;: &quot;cz&quot;,&quot;commit&quot;: &quot;git add . &amp;&amp; cz&quot; 之后在提交代码，就可以在项目根目录下执行 123npm run commit# oryarn commit 生成 changelog如果项目中所有的 commit 都是按照上述格式提交的，那么 change log，就可以用脚本自动生成。 生成的文档包括以下三个部分。 123New featuresBug fixesBreaking changes 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 conventional-changelog 就是生成 Change log 的工具 安装 conventional-changelog123npm install conventional-changelog-cli --save-dev# oryarn add conventional-changelog-cli --dev 命令行执行以下命令就会在项目根目录下生成 CHANGELOG.md 1npx conventional-changelog -p angular -i CHANGELOG.md -s 之后在发布新的版本的时候都可以使用这个命令，往 CHANGELOG.md 文件中，添加新版本的log 可以把这个命令添加到 package.json 中的 scripts 下，方便之后的使用 1&quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s&quot; 之后就可以使用以下命令往 CHANGELOG.md 文件中，添加新版本的log 123npm run changelog# or yarn changelog 相关资料阮一峰 Commit message 和 Change log 编写指南 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：集成axios","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第三篇-vue3 项目中配置模式和环境变量","slug":"第三篇-vue3-项目中配置模式和环境变量","date":"2021-09-08T03:15:47.000Z","updated":"2021-09-08T10:07:19.855Z","comments":true,"path":"2021/09/08/第三篇-vue3-项目中配置模式和环境变量/","link":"","permalink":"https://wukang0718.com/2021/09/08/%E7%AC%AC%E4%B8%89%E7%AF%87-vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"","text":"Vue内置的模式Vue CLI 内置了三种模式 developement 模式，使用 vue-cli-service serve 命令的时候，启动的开发环境就是这个模式，这个模式下运行的 webpack 会启动热更新，不会对资源进行 hash 也不会打出 vendor bundles，目的是为了在开发的时候能够快速重新构建。 test 模式，使用 vue-cli-service test:unit 命令的时候，启动的单元测试的环境就是这个模式，这个模式下的 webpack 不会处理图片以及一些对单元测试非必需的其他资源。 production 模式，vue-cli-service build 命令的时候，运用的就是这个模式，这个模式的 webpack 会运行 mode=production 的配置 自定义运行模式在执行 vue-cli-service 的命令的时候，可以通过 --mode 指定想要运行的模式，这将会覆盖默认的模式 例如在公司开发中，都会有一个测试环境，那么这个测试环境会有一些和开发/生产环境都不一样的东西，比如说我们后端服务的url，那么我们就可以给这个测试环境的打包指定一个模式，这样在打包的时候，会从指定模式的环境文件中加载环境变量，在 package.json 中添加一个 script 命令 &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;， 注意：尽量不要和默认的模式冲突 package.json 123456789101112&#123; ... &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;build:t&quot;: &quot;vue-cli-service build --mode t&quot;, &quot;test:unit&quot;: &quot;vue-cli-service test:unit&quot;, &quot;test:e2e&quot;: &quot;vue-cli-service test:e2e&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125; ...&#125; 执行 npm run build:t 的时候会运行 t 模式，会从 .env / .env.local / .env.t / .env.t.local 这些文件中加载环境变量，稍后来创建环境文件 Vue内置的环境变量Vue CLI 内置了两个环境变量 环境变量/模式 development test production NODE_ENV development test production BASE_URL（就是vue.config.js中的publicPath ，默认是 /） / / / 自定义环境变量 当运行 vue-cli-service 命令时，所有的环境变量都从对应的环境文件中载入，这就给我们提供了自定义环境变量的方式 什么是环境文件在项目根目录下可以创建四种形式的环境文件 1234.env # 在所有的环境中被载入.env.local # 在所有的环境中被载入，但会被 git 忽略.env.[mode] # 只在指定的模式中被载入.env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 环境文件只包含环境变量的“键=值”对： 1VUE_APP_BASE_URL=&quot;http://dev.server.com&quot; // 后端服务的url 环境文件的优先级 Vue CLI 启动时已经存在的环境变量拥有最高优先级，不会被 .env 文件覆盖，但是可以被 .env.[mode] 文件覆盖 为一个特定模式准备的环境文件 (例如 .env.t) 将会比一般的环境文件 (例如 .env) 拥有更高的优先级。 环境文件是通过运行 vue-cli-service 命令载入的，因此环境文件发生变化，你需要重启服务。 动态计算环境变量在 vue.config.js 文件中计算环境变量。它们仍然需要以 VUE_APP_ 前缀开头。 例如计算每次编译的版本和时间 1234/* eslint-disable @typescript-eslint/no-var-requires */const pkg = require(&quot;./package.json&quot;);process.env.VUE_APP_VERSION = pkg.version;process.env.VUE_APP_DATE_TIME = new Date().toLocaleString(); 环境变量的运用只有 NODE_ENV，BASE_URL 和以 VUE_APP_ 开头的变量将通过 webpack.DefinePlugin 静态地嵌入到代码中 例如上面提到的 VUE_APP_BASE_URL 就是已 VUE_APP 开头的 建议不要在任何文件修改 BASE_URL 的值，在执行 vue-cli-service build 命令的模式环境文件里都建议把 NODE_ENV 改成 production 先来配置一下环境变量看一下环境变量的用法 在根目录新建以下文件 .env.development 指定开发环境使用的环境变量 .env.production 指定生产环境使用的环境变量 .env.t 指定测试环境使用的环境变量 就简单配置一个用来区分运行环境的环境变量 VUE_APP_ENV ，这个变量可以任意取，只要求已 VUE_APP 开头，并且应该在所有的环境文件都包含这个环境变量 .env.development 1VUE_APP_ENV=dev .env.production 1VUE_APP_ENV=prod .env.t 1VUE_APP_ENV=t 在项目中使用环境变量通过 process.env.[环境变量] 的方式获取到运行模式的环境文件配置的环境变量的值 在 src/App.vue 中使用一下 123456789101112&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 忽略其他代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&#123;&#123; env &#125;&#125;&lt;/div&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; Ref, ref &#125; from &quot;@vue/reactivity&quot;;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;const env: Ref = ref(process.env.VUE_APP_ENV); // 启动项目这个值是dev&lt;/script&gt; 运行其他模式看一下结果，命令行执行 123yarn serve --mode t#ornpm run serve --mode t 运行 production 模式 123yarn serve --mode production#ornpm run serve --mode production 环境变量不只是在 src 下的文件可以使用，在根目录下的 babel.config.js / vue.config.js 等文件中也可以使用. 在 public/index.html 中使用环境变量所有解析出来的环境变量都可以在 public/index.html 中以 **HTML 插值**中介绍的方式使用。 因为 index 文件被用作模板，所以你可以使用 lodash template 语法插入内容： &lt;%= VALUE %&gt; 用来做不转义插值； &lt;%- VALUE %&gt; 用来做 HTML 转义插值； &lt;% expression %&gt; 用来描述 JavaScript 流程控制。 例如在 index.html 使用一个 meta 标签标记我们项目的模式、版本和打包的时间 123&lt;meta content=&quot;&lt;%= VUE_APP_ENV %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_VERSION %&gt;&quot;&gt;&lt;meta content=&quot;&lt;%= VUE_APP_DATE_TIME %&gt;&quot;&gt; 执行打包命令看 dist 目录输出的html 123yarn build --mode development#or npm run build --mode development 运行 t 模式的打包 123yarn build:t#or npm run build:t 运行 production 模式的打包，build 的默认模式就是 production 123yarn build#or npm run build 实际开发中还需要的运行环境经过刚才的打包发现，在指定 --mode t 的时候，打包后的文件没有被压缩 这是因为没有指定 t 模式的 NODE_ENV=production ，所以使用的是 development 的 webpack 配置 所以要在环境文件中指定 NODE_ENV 的值 .env.development 1NODE_ENV=development .env.t 1NODE_ENV=production .env.production 1NODE_ENV=production 再次执行 yarn build:t 或 npm run build:t，dist 目录下的文件就已经是压缩过的了 还有其他实际开发中需要配置的环境变量，比如后端接口的地址，具体看自己项目吧 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：添加工具规范 git commit message","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第二篇-Vue3 项目中集成 element-plus","slug":"第二篇-Vue3-项目中集成-element-plus","date":"2021-09-07T11:06:07.000Z","updated":"2021-09-08T03:22:17.789Z","comments":true,"path":"2021/09/07/第二篇-Vue3-项目中集成-element-plus/","link":"","permalink":"https://wukang0718.com/2021/09/07/%E7%AC%AC%E4%BA%8C%E7%AF%87-Vue3-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90-element-plus/","excerpt":"","text":"基于上次使用 cli 搭建的 vue3 的项目来添加 element-plus cli搭建vue3项目 安装element-plus在项目所在目录打开命令行工具，执行以下命令安装 123npm install element-plus --save#or yarn add element-plus 我这里安装的最新版本是 1.1.0-beta.9 升级sass、sass-loader为什么要升级 sass、 sass-loader? 使用脚手架安装的 sass 的版本是 1.26.5 ， sass-loader 的版本是 8.0.2，而 element-plus@1.1.0-beta.9 版本的源码中使用的 sass 的版本是 1.39.0, sass-loader 的版本是 10.1.1 那我们就需要安装一下这两个版本，命令行执行以下命令 123npm install sass@1.39.0 sass-loader@10.1.1 --save-dev#or yarn add sass@1.39.0 sass-loader@10.1.1 --dev 使用按需引入为什么要使用按需引入? element-plus 的组件比较多，而我们的项目开发中并不一定会用到所有的组件，如果我们直接引入所有的组件，那么项目打包之后的文件体积较大，会导致浏览器的加载时间长，从而导致一些白屏时间长等的问题。 使用按需引入之后，在项目打包的时候，只会把我们引入的组件进行打包，其他我们没有引入使用的组件，不会打包我们的项目中，减少我们项目的体积，加快浏览器的加载效率。 配置按需引入 首先需要下载一个 babel 的插件 babel-plugin-import，命令行执行 123npm install babel-plugin-import --save-dev#oryarn add babel-plugin-import --dev 找到项目根目录下的 babel.config.js 文件 添加 babel.config.js 配置，将文件内容修改为 1234567891011121314151617module.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [ [ &quot;import&quot;, &#123; libraryName: &quot;element-plus&quot;, // 引入组件 customName: (name) =&gt; &#123; name = name.slice(3); return `element-plus/lib/components/$&#123;name&#125;`; &#125;, // 不引入样式，因为之后会做主题定制，所以需要引入所有样式的scss文件 &#125;, ], ],&#125;; 测试按需引入是否正确在 src/main.ts 中，引入 element-plus 的样式文件 1import &quot;element-plus/dist/index.css&quot;; 在 src/App.vue 中，添加 script 代码 123&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt; 在 template 中添加一个 el-button 组件 1&lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; App.vue 123456789101112131415&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ElButton &#125; from &quot;element-plus&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ... 省略css代码&lt;/style&gt; 运行项目，浏览器访问 el-button 组件就很好的显示在了页面上 把按需引入提取到单独的目录为什么要提取到单独的目录来，有一个好处就是只需要在这里引入一次，并注册成全局的组件之后，就不需要在每个需要用到 element-plus 的组件里面再次引入了。 我一般会在 src 目录下，创建一个 theme 文件夹，专门做按需加载和主题定制 创建一个 theme 文件夹，并在目录下创建一个 index.ts 的文件 将刚才引入 el-button 的代码放到这个文件中，并将组件注册为全局的组件，在这里文件里，我们将导出一个函数，这个函数会作为 Vue 的一个插件，在 main.ts 中通过 app.use() 的方式注册到全局 index.ts 123456import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.use(ElButton);&#125;; main.ts 123456789101112import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;import store from &quot;./store&quot;;import Element from &quot;./theme&quot;;const app = createApp(App);app.use(store);app.use(router);app.use(Element);app.mount(&quot;#app&quot;); 测试一下我们的提取的按需引入是否正确 删掉刚才在 App.vue 中添加的 script 标签 1234567891011&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;router-view /&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt; 刷新浏览器，发现 el-button 的组件渲染的和之前一样，没有问题 配置 element-plus 的全局属性element-plus 还为我们提供了两个可以全局配置的属性， size 和 zIndex，还是在我们的 theme/index.ts 文件中配置，修改导出的函数，给 app.config.globalProperties.$ELEMENT 属性赋值 1234export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton);&#125;; 然后打开浏览器，可以发现 el-button 的按钮，比刚才小了很多了 配置 i18nElementPlus 组件内部默认使用英语，如果我们希望我们的项目中默认使用中文，就需要对 element-plus 配置 i18n，先来看一个默认英文的例子 在 theme/index.ts 文件中引入 ElCalendar 组件 12345678import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar);&#125;; 在 src/App.vue 中使用 ElCalendar 组件 123456789&lt;template&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt;&lt;/template&gt; 打开浏览器会发现日历的头部和按钮都是显示的英文 接下来我们配置 i18n，还是在我们的 theme/index.ts 文件中，引入 ElConfigProvider 组件，并在 src/App.vue 中使用 theme/index.ts 123456789import &#123; App &#125; from &quot;vue&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;div id=&quot;nav&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; | &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt; &lt;/div&gt; &lt;el-button type=&quot;primary&quot;&gt;测试按需引入&lt;/el-button&gt; &lt;el-calendar /&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import zhCn from &quot;element-plus/lib/locale/lang/zh-cn&quot;;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt; // ...&lt;/style&gt; 再次打开浏览器，就可以看到日历的按钮已经变成中文了，但是日历的头部还是英文的展示，这是因为 element-plus 的中的时间和日期相关的组件，都使用了 dayjs 格式化，所以我们这里想把日历的头部 改成中文还需要引入一下 dayjs 的中文包 在 theme/index.ts 中添加引入 1import &quot;dayjs/locale/zh-cn&quot;; 配置主题定制element-plus 给我们提供了一套默认的主题，同时给我们提供了四种方法，可以进行不同程度的样式自定义。这里只说其中的一种，其他的方式，感兴趣的可以前往官网查阅 通过修改scss变量的方式，替换主题的样式在我们的 src/theme 目录下新建一个 element-variables.scss 的文件，之后我们需要定制的 element-plus 主题的 scss 变量都会在这个文件重写。 不要使用官网推荐的 element-theme 工具，已经很久没有人维护了，在最新版本的node环境下使用会报错。 在我们项目的根目录下找到 node_modules/element-plus/theme-chalk/src/common/var.scss 这个文件，这里面所有后面带有 !default 的就是我们可以修改的所有的 scss 的变量了 比如说我们想要修改一下 primary 的样式，我们查找 var.scss 文件发现，关于 primary 颜色的定义就在第 21 行，$--colors 的初始值就是带有 !default 的， 我们在 element-variables.scss 文件中对 $--colors 重新赋值就可以修改 primary 的颜色 src/theme/element-variables.scss 12345$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: #000, ),); 注意：要通过修改scss变量的方式自定义主题，必须重新设置 font 文件路径 引入 element-plus/packages/theme-chalk/src/index.scss 之后，就可以修改 scss 的变量了 所以我们在 src/theme 文件夹下在新建一个 index.scss 文件，用来引入自定义的主题并处理 font 路径和 element-plus 的 scss 文件 src/theme/index.scss 123@import &quot;./element-variables.scss&quot;;$--font-path: &quot;~element-plus/theme-chalk/fonts&quot;; @import &quot;~element-plus/packages/theme-chalk/src/index&quot;; 在 src/theme/index.ts 文件中引入这个文件 import &quot;./index.scss&quot;; src/theme/index.ts 1234567891011import &#123; App &#125; from &quot;vue&quot;;import &quot;dayjs/locale/zh-cn&quot;;import &#123; ElButton, ElCalendar, ElConfigProvider &#125; from &quot;element-plus&quot;;import &quot;./index.scss&quot;;export default (app: App): void =&gt; &#123; app.config.globalProperties.$ELEMENT = &#123; size: &quot;small&quot; &#125;; app.use(ElButton); app.use(ElCalendar); app.use(ElConfigProvider);&#125;; 删除 src.main.ts 中引入样式的代码 import &quot;element-plus/dist/index.css&quot;; 刷新浏览器就可以看到我们修改的主题的样式了 配置 scss 全局变量文件在我们的项目开发过程中，不可能只使用 element-plus 的组件和样式，所以我们会需要维护一套我们自己的 scss ，为了样式的统一和以后的好维护，我们应该使用和 element-plus 类似的这种全局变量的方式，定义我们的统一的颜色、边框等等 在 src/assets 目录下新建一个 scss 文件夹，在其中新建以下文件 var.scss 定义全局的变量 mixin.scss 定义全局的混入 fun.scss 定义全局的函数 common.scss 全局的样式，这个文件会定义一些具体的选择器的样式，上面的其他文件中定义都是不会被直接编译出 css 代码的 在 sass-loader中配置成全局scss文件在项目根目录下创建 vue.config.js 文件，并添加 css 配置 vue.config.js 1module.exports = &#123; css: &#123; loaderOptions: &#123; scss: &#123; additionalData: ` @import &quot;~@/assets/scss/var.scss&quot;; @import &quot;~@/assets/scss/mixin.scss&quot;; @import &quot;~@/assets/scss/fun.scss&quot;; `, &#125;, &#125;, &#125;,&#125;; 验证一下全局的 scss 文件是否配置成功 在 src/assets/scss/var.sass 中添加变量 $primary-color: red;，把刚才修改的 src/theme/element-variables 文件中的 primary 的颜色设置成 $primary-color src/assets/scss/var.scss 1$primary-color: red; src/theme/element-variables.scss 1$--colors: ( &#x27;primary&#x27;: ( &#x27;base&#x27;: $primary-color, ),); 在 src/assets/scss/fun.scss 文件中添加一个 toRem 函数，在 src/App.vue 中调用这个函数 在 src/App.vue 中添加一个标签 &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt;，在 style 标签里给 div 定义一个样式，使用 $primary-color 变量和 toRem 函数 src/assets/scss/fun.scss 1@function toRem($px) &#123; @return $px / 75px * 1rem;&#125; 实际开发中，如果有需要 px 转 rem 的操作，建议可以使用 postcss 的插件 pxtorem ，可以不用每次都要都要写 toRem()，这里只是用来做一下演示 src/App.vue 123456789101112131415161718&lt;template&gt; &lt;el-config-provider :locale=&quot;zhCn&quot;&gt; &lt;!-- 省略其余代码 --&gt; &lt;div class=&quot;bg-red&quot;&gt;&lt;/div&gt; &lt;router-view /&gt; &lt;/el-config-provider&gt;&lt;/template&gt;&lt;script&gt; // ... 省略js代码&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;.bg-red &#123; width: toRem(200px); height: toRem(200px); background: $primary-color;&#125;&lt;/style&gt; 在项目编译的时候给出了以下警告，使用 / 表示除法已经被废弃，应该使用 math.div 方法 修改一下 src/assets/scss/fun.scss 文件 1234@use &quot;sass:math&quot;;@function toRem($px) &#123; @return math.div($px, 75px) * 1rem;&#125; 打开浏览器可以看到红色的按钮，和 div 的样式，宽高已经是 rem 的单位，并且背景也红色 最后，在 src/main.ts 中引入 common.scss 文件 1import &quot;@/assets/scss/common.scss&quot;; 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：配置运行环境","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"第一篇-使用vue-cli 创建Vue3项目","slug":"第一篇-使用vue-cli 创建Vue3项目","date":"2021-09-06T06:24:36.000Z","updated":"2021-09-08T10:07:39.462Z","comments":true,"path":"2021/09/06/第一篇-使用vue-cli 创建Vue3项目/","link":"","permalink":"https://wukang0718.com/2021/09/06/%E7%AC%AC%E4%B8%80%E7%AF%87-%E4%BD%BF%E7%94%A8vue-cli%20%E5%88%9B%E5%BB%BAVue3%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"第一步：安装 nodejs安装已经安装可以跳过到 下一步 nodejs 官网地址：https://nodejs.org/zh-cn/download/ 长期维护版（即稳定版）下选择对应的操作系统点击即可下载，之后一直点击下一步，即可完成安装 安装完成后检查是否安装成功打开命令行窗口 windows系统使用win+R，之后输入 cmd mac 用户，打开 terminal / 终端 输入 node -v 查看 nodejs 版本，输入 npm -v 查看 npm 版本 1234node -v# v14.17.4npm -v# 7.21.1 显示对应的版本就表示安装成功 第二步：安装vue-cli安装已经安装可以跳过到 下一步 vue-cli 官网：https://cli.vuejs.org/zh/guide/installation.html 建议全局安装 在命令行执行以下命令，mac用户需要 sudo 执行 123npm install -g @vue/cli# ORyarn global add @vue/cli 安装完成后检查是否安装成功命令行执行 vue --version 12vue --version# @vue/cli 4.5.13 看到正确的版本号，表示安装成功 第三步：使用脚手架创建项目在命令行执行 vue create &lt;app-name&gt; 命令创建项目，例如，我现在创建一个名叫 cli-create-project 的项目，在命令执行 1vue create cli-create-project 选择 preset 命令行窗口会提示请选择一个 preset，建议选择第三个 Manually select features，选择第一个或者第二个，创建的项目会比较简陋，只有 babel 和 eslint ，项目中必备的 vue-router 等的不会被创建，选择第三项（手动选择功能）,按上下键选择，回车键确认，进入下一步 选择功能 回车之后，命令行窗口就到了选择功能，按上下键切换功能，空格选中和取消选中，回车会进入到下一步。 Choose Vue version 必选，之后会选择使用Vue2还是Vue3 Babel 必选 TypeScript 选中之后，项目会安装typescript的依赖，建议是Vue2的话，就不用选了，Vue3的还是可以使用TypeScript的 Progressive Web App (PWA) Support 可选可不选，在项目中添加pwa支持， 会在项目中添加 Service Workers Router 必选，在项目中安装 vue-router Vuex 按照项目的需求来，会在项目中安装 vuex，一般不是很小的项目的话，都会用到的 CSS Pre-processors 一般都选，安装css的预处理器 Linter / Formatter 必选，安装 eslint 和一个格式化代码的工具会校验和格式化代码 Unit Testing 集成单元测试，看自己情况安装吧 E2E Testing 集成端到端测试，也是看自己情况安装吧 回车进入下一步 选择 vue 版本，这里选择3.x 回车进入下一步 选择是否使用类组件语法，Vue3的话就使用不了，输入 n 回车 选择是否使用Babel与TypeScript一起用于自动检测的填充，使用，输入 Y 回车 选择是否使用 history 模式的路由，是否都是可以的，我就选择使用，输入 Y 回车 选择一个 css 的预处理器，这里按照个人的喜好选择吧，我后续要添加 element-plus 的UI框架，所以就选择 Sass/SCSS (with dart-sass)，回车到下一步 选择一个 lint 和 一个格式化代码的工具，我比较喜欢用 ESLint + Prettier ，就选择这个了,回车到下一步 选择 lint 执行的时机，在保存时执行，或者是在代码提交的时候，需要自动修复，我不需要自动修复，就选择 Lint on save 了，回车到下一步 选择一个单元测试的工具，我用 Jest 比较多，这里就选择 jest，如果在第二步的时候，没有选择 Unit Testing ，就没有这一步 选择一个端到端的测试框架，同样我用 Cypress，比较多，我就选择这个了，同样的，如果在第二步的时候，没有选择 E2E Testing，就没有这一步 选择一个存放插件（eslint、postcss、babel…）配置文件的位置 In dedicated config files 存放在单独的配置文件中，会在项目目录下生成 babel.config.js 之类的文件 In package.json 把插件的配置都写在 packgae.json 文件中 个人喜欢单独文件存放，就选择 In dedicated config files 了，回车到下一步 是否要把这些配置保存为一个将来可复用的 preset。 选择 Y 的话，会把 preset 保存在用户的 home 目录下一个名为 .vuerc 的 JSON 文件里。如果你想要修改被保存的 preset / 选项，可以编辑这个文件。 不想保存的话就输入n，回车开始下载项目模版并安装依赖 安装完成，进入项目目录 1cd cli- create-project 这里默认安装的 vue、vue-router 、vuex 的版本都比较低，先升级一下版本 123npm install vue@next vue-router@next vuex@next --save#or yarn add vue@next vue-router@next vuex@next --save 升级完版本之后，运行项目看一下是否可以成功运行 123npm run serve#oryarn serve 启动成功 在浏览器访问 使用 vue-cli 创建 vue3 项目就成功了 完结项目已经上传到 github 和 gitee GitHub: https://github.com/wukang0718/cli-create-project Gitee: https://gitee.com/wu_kang0718/cli-create-project 下一篇：在项目中添加 element-plus","categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"}]},{"title":"vue-router中query参数做自动加密、解密","slug":"vue-router中query参数做自动加密、解密","date":"2021-09-04T10:46:27.000Z","updated":"2021-09-07T12:50:21.685Z","comments":true,"path":"2021/09/04/vue-router中query参数做自动加密、解密/","link":"","permalink":"https://wukang0718.com/2021/09/04/vue-router%E4%B8%ADquery%E5%8F%82%E6%95%B0%E5%81%9A%E8%87%AA%E5%8A%A8%E5%8A%A0%E5%AF%86%E3%80%81%E8%A7%A3%E5%AF%86/","excerpt":"","text":"vue-router 插件，对vue-router使用中query参数做自动加密、解密仓库地址​ github: https://github.com/wukang0718/vueRouterEncryption ​ gitee: https://gitee.com/wu_kang0718/vueRouterEncryption 使用方式 加密需要依赖 crypto-js 库，安装： npm 1npm install crypto-js --save yarn 1yarn add crypto-js 将utils文件夹放入项目 （最好是放在router目录下 ） 中，在router的初始化文件中，引入utils/query.js的stringifyQuery和parseQuery方法，在new VueRouter是时候传递参数， 修改utils/encryption.js中的baseCryptoCode设置每个项目唯一的值 例：（参考index.js） 1234567891011121314151617import Vue from &quot;vue&quot;import VueRouter from &quot;vue-router&quot;;import &#123; stringifyQuery, parseQuery &#125; from &quot;./utils/query&quot;;Vue.use(VueRouter);const routes = [];const router = new VueRouter(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, stringifyQuery: stringifyQuery, // 序列化query参数 parseQuery: parseQuery, // 反序列化query参数 routes&#125;);export default router 结构 utils/encryption.js 文件提供加密和解密算法（默认在index.html中已经引入了crypto-js.js） getEncrypt 加密 对应的解密方法（getDecrypt） getEncryptToBase64 加密后转base64 对应的解密方法（getDecryptByBase64） getDecrypt 解密 对应的加密方法（getEncrypt） getDecryptByBase64 对base64数据解密 先解析base64，在做解密 对应的加密方法（getEncryptToBase64） utils/query.js 文件提供了序列化和反序列化的方法 stringifyQuery 序列化对象并 加密 parseQuery 解密 反序列化对象 原理 在创建路由的时候，添加两个方法 stringifyQuery: 序列化传入的query参数，方法可以接收一个对象参数 在new Router的时候传递这个属性，在序列化query参数的就执行这个方法，不会执行默认的方法，序列化后在地址栏显示序列化之后的参数 parseQuery: 解析地址栏参数，方法接收一个字符串参数 在new Router的时候传递这个属性，在解析query参数的时候，回执行这个方法，不会在执行默认的方法， 注： 这个方法只解析path中的参数，或者浏览器刷新的时候的地址栏的参数，不会对在query参数对处理，如： 123456this.$router.push(&#123; path: &quot;foo?a=123&quot;, query: &#123; b: 345 &#125;&#125;) 在执行这段代码的时候，parseQuery方法不会对query:&#123;b: 345&#125;进行解析,会解析path:&quot;foo?a=123&quot;中的a=123的字符串 序列化 vue-router在执行createRoute的时候，获取fullPath会执行getFullPath方法 createRouter 方法 会获取在 new VueRouter的时候传递的stringifyQuery方法，如果没有这个方法，就会在getFullPath的时候，使用默认的方法 源码位置：“/vue-router/src/utils/route.js” 12345678910111213141516171819202122232425262728export function createRoute ( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter): Route &#123; const stringifyQuery = router &amp;&amp; router.options.stringifyQuery let query: any = location.query || &#123;&#125; try &#123; query = clone(query) &#125; catch (e) &#123;&#125; const route: Route = &#123; name: location.name || (record &amp;&amp; record.name), meta: (record &amp;&amp; record.meta) || &#123;&#125;, path: location.path || &#x27;/&#x27;, hash: location.hash || &#x27;&#x27;, query, params: location.params || &#123;&#125;, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] &#125; if (redirectedFrom) &#123; route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) &#125; return Object.freeze(route)&#125; getFullPath 方法接收两个参数（路由对象， 序列化query的方法） 源码： 1234567function getFullPath ( &#123; path, query = &#123;&#125;, hash = &#x27;&#x27; &#125;, _stringifyQuery): string &#123; const stringify = _stringifyQuery || stringifyQuery return (path || &#x27;/&#x27;) + stringify(query) + hash&#125; 反序列化 在调用push的时候，会执行this.router.match方法，match方法会执行normalizeLocation normalizeLocation通过resolveQuery方法解析path中的query，传入的三个参数（path中的?之后的参数数据字符串，使用push或replace方法传递的query参数，反序列化参数的方法） 反序列化方法会通过router &amp;&amp; router.options.parseQuery获取，如果在new VueRouter的时候传递了parseQuery方法，就是用该方法，如果没有就在resolveQuery方法中使用默认的方法 源码地址：“/vue-router/src/utils/location.js” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export function normalizeLocation ( raw: RawLocation, current: ?Route, append: ?boolean, router: ?VueRouter): Location &#123; let next: Location = typeof raw === &#x27;string&#x27; ? &#123; path: raw &#125; : raw // named target if (next._normalized) &#123; return next &#125; else if (next.name) &#123; next = extend(&#123;&#125;, raw) const params = next.params if (params &amp;&amp; typeof params === &#x27;object&#x27;) &#123; next.params = extend(&#123;&#125;, params) &#125; return next &#125; // relative params if (!next.path &amp;&amp; next.params &amp;&amp; current) &#123; next = extend(&#123;&#125;, next) next._normalized = true const params: any = extend(extend(&#123;&#125;, current.params), next.params) if (current.name) &#123; next.name = current.name next.params = params &#125; else if (current.matched.length) &#123; const rawPath = current.matched[current.matched.length - 1].path next.path = fillParams(rawPath, params, `path $&#123;current.path&#125;`) &#125; else if (process.env.NODE_ENV !== &#x27;production&#x27;) &#123; warn(false, `relative params navigation requires a current route.`) &#125; return next &#125; const parsedPath = parsePath(next.path || &#x27;&#x27;) const basePath = (current &amp;&amp; current.path) || &#x27;/&#x27; const path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath const query = resolveQuery( parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery ) let hash = next.hash || parsedPath.hash if (hash &amp;&amp; hash.charAt(0) !== &#x27;#&#x27;) &#123; hash = `#$&#123;hash&#125;` &#125; return &#123; _normalized: true, path, query, hash &#125;&#125;","categories":[{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"}]},{"title":"为什么微任务比宏任务执行快","slug":"为什么微任务比宏任务执行快","date":"2021-09-04T07:49:41.000Z","updated":"2021-09-07T12:50:13.765Z","comments":true,"path":"2021/09/04/为什么微任务比宏任务执行快/","link":"","permalink":"https://wukang0718.com/2021/09/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%AE%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%AE%8F%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%BF%AB/","excerpt":"","text":"为什么微任务比宏任务执行快 微任务叫 microtask 称为 jobs，是由JavaScript自身发起的 宏任务叫 macrotask 称为 task，是由宿主环境发起的 Event Loop中，每一次循环称为tick 主要区别 宏任务（macrotask） 微任务（microtask） 谁发起的 Nodejs/浏览器 JavaScript自身 具体事件 script 标签setTimeout/setIntervalUiRenderingpostMessage/messageChannelsetImmediate/IO PromiseMutationObserverprocess.nextTick 谁先执行 后执行 先执行 会触发新一轮的tick吗 会 不会","categories":[{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/categories/vue/"},{"name":"vue3项目","slug":"vue/vue3项目","permalink":"https://wukang0718.com/categories/vue/vue3%E9%A1%B9%E7%9B%AE/"},{"name":"Vue插件","slug":"Vue插件","permalink":"https://wukang0718.com/categories/Vue%E6%8F%92%E4%BB%B6/"},{"name":"面试题","slug":"面试题","permalink":"https://wukang0718.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://wukang0718.com/tags/vue-cli/"},{"name":"vue3","slug":"vue3","permalink":"https://wukang0718.com/tags/vue3/"},{"name":"vue","slug":"vue","permalink":"https://wukang0718.com/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://wukang0718.com/tags/vue-router/"},{"name":"EventLoop","slug":"EventLoop","permalink":"https://wukang0718.com/tags/EventLoop/"},{"name":"微任务","slug":"微任务","permalink":"https://wukang0718.com/tags/%E5%BE%AE%E4%BB%BB%E5%8A%A1/"},{"name":"宏任务","slug":"宏任务","permalink":"https://wukang0718.com/tags/%E5%AE%8F%E4%BB%BB%E5%8A%A1/"}]}